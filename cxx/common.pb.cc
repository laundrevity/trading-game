// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#include "common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace ProtoCommon {
PROTOBUF_CONSTEXPR Instrument::Instrument(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.precision_)*/uint64_t{0u}} {}
struct InstrumentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstrumentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstrumentDefaultTypeInternal() {}
  union {
    Instrument _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstrumentDefaultTypeInternal _Instrument_default_instance_;
PROTOBUF_CONSTEXPR GenericReply::GenericReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_id_)*/0u
  , /*decltype(_impl_.error_code_)*/0u} {}
struct GenericReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericReplyDefaultTypeInternal() {}
  union {
    GenericReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericReplyDefaultTypeInternal _GenericReply_default_instance_;
PROTOBUF_CONSTEXPR InsertLimitOrder::InsertLimitOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.request_id_)*/0u
  , /*decltype(_impl_.side_)*/0
  , /*decltype(_impl_.volume_)*/uint64_t{0u}
  , /*decltype(_impl_.price_)*/int64_t{0}} {}
struct InsertLimitOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertLimitOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertLimitOrderDefaultTypeInternal() {}
  union {
    InsertLimitOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertLimitOrderDefaultTypeInternal _InsertLimitOrder_default_instance_;
PROTOBUF_CONSTEXPR InsertMarketOrder::InsertMarketOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.request_id_)*/0u
  , /*decltype(_impl_.side_)*/0
  , /*decltype(_impl_.volume_)*/uint64_t{0u}} {}
struct InsertMarketOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertMarketOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertMarketOrderDefaultTypeInternal() {}
  union {
    InsertMarketOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertMarketOrderDefaultTypeInternal _InsertMarketOrder_default_instance_;
PROTOBUF_CONSTEXPR CancelOrder::CancelOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.request_id_)*/0u
  , /*decltype(_impl_.side_)*/0
  , /*decltype(_impl_.price_)*/int64_t{0}} {}
struct CancelOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CancelOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CancelOrderDefaultTypeInternal() {}
  union {
    CancelOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CancelOrderDefaultTypeInternal _CancelOrder_default_instance_;
PROTOBUF_CONSTEXPR LevelUpdate::LevelUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.volume_)*/uint64_t{0u}
  , /*decltype(_impl_.price_)*/int64_t{0}
  , /*decltype(_impl_.side_)*/0} {}
struct LevelUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LevelUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LevelUpdateDefaultTypeInternal() {}
  union {
    LevelUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LevelUpdateDefaultTypeInternal _LevelUpdate_default_instance_;
PROTOBUF_CONSTEXPR Trade::Trade(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.passive_account_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.volume_)*/uint64_t{0u}
  , /*decltype(_impl_.price_)*/int64_t{0}
  , /*decltype(_impl_.passive_side_)*/0} {}
struct TradeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeDefaultTypeInternal() {}
  union {
    Trade _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeDefaultTypeInternal _Trade_default_instance_;
PROTOBUF_CONSTEXPR CreateMarket::CreateMarket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_name_)*/{}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.settlement_price_)*/int64_t{0}} {}
struct CreateMarketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateMarketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateMarketDefaultTypeInternal() {}
  union {
    CreateMarket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateMarketDefaultTypeInternal _CreateMarket_default_instance_;
PROTOBUF_CONSTEXPR CreateMarketReply::CreateMarketReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.error_code_)*/0u} {}
struct CreateMarketReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateMarketReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateMarketReplyDefaultTypeInternal() {}
  union {
    CreateMarketReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateMarketReplyDefaultTypeInternal _CreateMarketReply_default_instance_;
PROTOBUF_CONSTEXPR PositionUpdate::PositionUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instrument_)*/nullptr
  , /*decltype(_impl_.position_)*/int64_t{0}} {}
struct PositionUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionUpdateDefaultTypeInternal() {}
  union {
    PositionUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionUpdateDefaultTypeInternal _PositionUpdate_default_instance_;
PROTOBUF_CONSTEXPR Message::Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{}
  , /*decltype(_impl_.insert_limit_order_)*/nullptr
  , /*decltype(_impl_.insert_market_order_)*/nullptr
  , /*decltype(_impl_.cancel_order_)*/nullptr
  , /*decltype(_impl_.level_update_)*/nullptr
  , /*decltype(_impl_.trade_)*/nullptr
  , /*decltype(_impl_.create_market_)*/nullptr
  , /*decltype(_impl_.create_market_reply_)*/nullptr
  , /*decltype(_impl_.position_update_)*/nullptr} {}
struct MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageDefaultTypeInternal _Message_default_instance_;
}  // namespace ProtoCommon
static ::_pb::Metadata file_level_metadata_common_2eproto[11];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_common_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_common_2eproto = nullptr;

const uint32_t TableStruct_common_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Instrument, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Instrument, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Instrument, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Instrument, _impl_.precision_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::GenericReply, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::GenericReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::GenericReply, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::GenericReply, _impl_.error_code_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::GenericReply, _impl_.text_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _impl_.account_name_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertLimitOrder, _impl_.side_),
  2,
  1,
  0,
  4,
  5,
  3,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertMarketOrder, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertMarketOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertMarketOrder, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertMarketOrder, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertMarketOrder, _impl_.account_name_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertMarketOrder, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::InsertMarketOrder, _impl_.side_),
  2,
  1,
  0,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CancelOrder, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CancelOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CancelOrder, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CancelOrder, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CancelOrder, _impl_.account_name_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CancelOrder, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CancelOrder, _impl_.side_),
  2,
  1,
  0,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::LevelUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::LevelUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::LevelUpdate, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::LevelUpdate, _impl_.account_name_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::LevelUpdate, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::LevelUpdate, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::LevelUpdate, _impl_.side_),
  1,
  0,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Trade, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Trade, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Trade, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Trade, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Trade, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Trade, _impl_.passive_account_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Trade, _impl_.passive_side_),
  1,
  2,
  3,
  0,
  4,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarket, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarket, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarket, _impl_.settlement_price_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarket, _impl_.user_name_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarketReply, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarketReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarketReply, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarketReply, _impl_.error_code_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::CreateMarketReply, _impl_.text_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::PositionUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::PositionUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::PositionUpdate, _impl_.instrument_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::PositionUpdate, _impl_.account_name_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::PositionUpdate, _impl_.position_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.insert_limit_order_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.insert_market_order_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.cancel_order_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.level_update_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.trade_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.create_market_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.create_market_reply_),
  PROTOBUF_FIELD_OFFSET(::ProtoCommon::Message, _impl_.position_update_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::ProtoCommon::Instrument)},
  { 10, 19, -1, sizeof(::ProtoCommon::GenericReply)},
  { 22, 34, -1, sizeof(::ProtoCommon::InsertLimitOrder)},
  { 40, 51, -1, sizeof(::ProtoCommon::InsertMarketOrder)},
  { 56, 67, -1, sizeof(::ProtoCommon::CancelOrder)},
  { 72, 83, -1, sizeof(::ProtoCommon::LevelUpdate)},
  { 88, 99, -1, sizeof(::ProtoCommon::Trade)},
  { 104, 113, -1, sizeof(::ProtoCommon::CreateMarket)},
  { 116, 125, -1, sizeof(::ProtoCommon::CreateMarketReply)},
  { 128, 137, -1, sizeof(::ProtoCommon::PositionUpdate)},
  { 140, 155, -1, sizeof(::ProtoCommon::Message)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::ProtoCommon::_Instrument_default_instance_._instance,
  &::ProtoCommon::_GenericReply_default_instance_._instance,
  &::ProtoCommon::_InsertLimitOrder_default_instance_._instance,
  &::ProtoCommon::_InsertMarketOrder_default_instance_._instance,
  &::ProtoCommon::_CancelOrder_default_instance_._instance,
  &::ProtoCommon::_LevelUpdate_default_instance_._instance,
  &::ProtoCommon::_Trade_default_instance_._instance,
  &::ProtoCommon::_CreateMarket_default_instance_._instance,
  &::ProtoCommon::_CreateMarketReply_default_instance_._instance,
  &::ProtoCommon::_PositionUpdate_default_instance_._instance,
  &::ProtoCommon::_Message_default_instance_._instance,
};

const char descriptor_table_protodef_common_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014common.proto\022\013ProtoCommon\"+\n\nInstrumen"
  "t\022\n\n\002id\030\001 \002(\004\022\021\n\tprecision\030\002 \002(\004\"D\n\014Gene"
  "ricReply\022\022\n\nrequest_id\030\001 \002(\r\022\022\n\nerror_co"
  "de\030\002 \002(\r\022\014\n\004text\030\003 \001(\t\"\251\001\n\020InsertLimitOr"
  "der\022\022\n\nrequest_id\030\001 \002(\r\022+\n\ninstrument\030\002 "
  "\002(\0132\027.ProtoCommon.Instrument\022\024\n\014account_"
  "name\030\003 \002(\t\022\016\n\006volume\030\004 \002(\004\022\r\n\005price\030\005 \002("
  "\003\022\037\n\004side\030\006 \002(\0162\021.ProtoCommon.Side\"\233\001\n\021I"
  "nsertMarketOrder\022\022\n\nrequest_id\030\001 \002(\r\022+\n\n"
  "instrument\030\002 \002(\0132\027.ProtoCommon.Instrumen"
  "t\022\024\n\014account_name\030\003 \002(\t\022\016\n\006volume\030\004 \002(\004\022"
  "\037\n\004side\030\005 \002(\0162\021.ProtoCommon.Side\"\224\001\n\013Can"
  "celOrder\022\022\n\nrequest_id\030\001 \002(\r\022+\n\ninstrume"
  "nt\030\002 \002(\0132\027.ProtoCommon.Instrument\022\024\n\014acc"
  "ount_name\030\003 \002(\t\022\r\n\005price\030\004 \002(\003\022\037\n\004side\030\005"
  " \002(\0162\021.ProtoCommon.Side\"\220\001\n\013LevelUpdate\022"
  "+\n\ninstrument\030\001 \002(\0132\027.ProtoCommon.Instru"
  "ment\022\024\n\014account_name\030\002 \002(\t\022\016\n\006volume\030\003 \002"
  "(\004\022\r\n\005price\030\004 \002(\003\022\037\n\004side\030\005 \002(\0162\021.ProtoC"
  "ommon.Side\"\225\001\n\005Trade\022+\n\ninstrument\030\001 \002(\013"
  "2\027.ProtoCommon.Instrument\022\016\n\006volume\030\002 \002("
  "\004\022\r\n\005price\030\003 \002(\003\022\027\n\017passive_account\030\004 \002("
  "\t\022\'\n\014passive_side\030\005 \002(\0162\021.ProtoCommon.Si"
  "de\"h\n\014CreateMarket\022+\n\ninstrument\030\001 \002(\0132\027"
  ".ProtoCommon.Instrument\022\030\n\020settlement_pr"
  "ice\030\002 \002(\003\022\021\n\tuser_name\030\003 \003(\t\"b\n\021CreateMa"
  "rketReply\022+\n\ninstrument\030\001 \002(\0132\027.ProtoCom"
  "mon.Instrument\022\022\n\nerror_code\030\002 \002(\r\022\014\n\004te"
  "xt\030\003 \001(\t\"e\n\016PositionUpdate\022+\n\ninstrument"
  "\030\001 \002(\0132\027.ProtoCommon.Instrument\022\024\n\014accou"
  "nt_name\030\002 \002(\t\022\020\n\010position\030\003 \002(\003\"\321\003\n\007Mess"
  "age\022&\n\004type\030\001 \003(\0162\030.ProtoCommon.MessageT"
  "ype\0229\n\022insert_limit_order\030\002 \001(\0132\035.ProtoC"
  "ommon.InsertLimitOrder\022;\n\023insert_market_"
  "order\030\003 \001(\0132\036.ProtoCommon.InsertMarketOr"
  "der\022.\n\014cancel_order\030\004 \001(\0132\030.ProtoCommon."
  "CancelOrder\022.\n\014level_update\030\005 \001(\0132\030.Prot"
  "oCommon.LevelUpdate\022!\n\005trade\030\006 \001(\0132\022.Pro"
  "toCommon.Trade\0220\n\rcreate_market\030\007 \001(\0132\031."
  "ProtoCommon.CreateMarket\022;\n\023create_marke"
  "t_reply\030\010 \001(\0132\036.ProtoCommon.CreateMarket"
  "Reply\0224\n\017position_update\030\t \001(\0132\033.ProtoCo"
  "mmon.PositionUpdate*\301\001\n\013MessageType\022\021\n\rG"
  "ENERIC_REPLY\020\000\022\026\n\022INSERT_LIMIT_ORDER\020\001\022\027"
  "\n\023INSERT_MARKET_ORDER\020\002\022\020\n\014CANCEL_ORDER\020"
  "\003\022\020\n\014LEVEL_UPDATE\020\004\022\t\n\005TRADE\020\005\022\021\n\rCREATE"
  "_MARKET\020\006\022\027\n\023CREATE_MARKET_REPLY\020\007\022\023\n\017PO"
  "SITION_UPDATE\020\010*\031\n\004Side\022\007\n\003BUY\020\000\022\010\n\004SELL"
  "\020\001"
  ;
static ::_pbi::once_flag descriptor_table_common_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_common_2eproto = {
    false, false, 1922, descriptor_table_protodef_common_2eproto,
    "common.proto",
    &descriptor_table_common_2eproto_once, nullptr, 0, 11,
    schemas, file_default_instances, TableStruct_common_2eproto::offsets,
    file_level_metadata_common_2eproto, file_level_enum_descriptors_common_2eproto,
    file_level_service_descriptors_common_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_common_2eproto_getter() {
  return &descriptor_table_common_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_common_2eproto(&descriptor_table_common_2eproto);
namespace ProtoCommon {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_common_2eproto);
  return file_level_enum_descriptors_common_2eproto[0];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_common_2eproto);
  return file_level_enum_descriptors_common_2eproto[1];
}
bool Side_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Instrument::_Internal {
 public:
  using HasBits = decltype(std::declval<Instrument>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_precision(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Instrument::Instrument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.Instrument)
}
Instrument::Instrument(const Instrument& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Instrument* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.precision_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.precision_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.precision_));
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.Instrument)
}

inline void Instrument::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.precision_){uint64_t{0u}}
  };
}

Instrument::~Instrument() {
  // @@protoc_insertion_point(destructor:ProtoCommon.Instrument)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Instrument::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Instrument::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Instrument::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.Instrument)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.precision_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.precision_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Instrument::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 precision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_precision(&has_bits);
          _impl_.precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Instrument::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.Instrument)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint64 precision = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_precision(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.Instrument)
  return target;
}

size_t Instrument::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.Instrument)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_precision()) {
    // required uint64 precision = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_precision());
  }

  return total_size;
}
size_t Instrument::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.Instrument)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint64 precision = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_precision());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Instrument::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Instrument::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Instrument::GetClassData() const { return &_class_data_; }


void Instrument::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Instrument*>(&to_msg);
  auto& from = static_cast<const Instrument&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.Instrument)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.precision_ = from._impl_.precision_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Instrument::CopyFrom(const Instrument& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.Instrument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Instrument::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Instrument::InternalSwap(Instrument* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Instrument, _impl_.precision_)
      + sizeof(Instrument::_impl_.precision_)
      - PROTOBUF_FIELD_OFFSET(Instrument, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Instrument::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[0]);
}

// ===================================================================

class GenericReply::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericReply>()._impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

GenericReply::GenericReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.GenericReply)
}
GenericReply::GenericReply(const GenericReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GenericReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.error_code_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.request_id_, &from._impl_.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.error_code_) -
    reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_code_));
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.GenericReply)
}

inline void GenericReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.request_id_){0u}
    , decltype(_impl_.error_code_){0u}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GenericReply::~GenericReply() {
  // @@protoc_insertion_point(destructor:ProtoCommon.GenericReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenericReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void GenericReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GenericReply::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.GenericReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.text_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.error_code_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenericReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_error_code(&has_bits);
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.GenericReply.text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenericReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.GenericReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  // required uint32 error_code = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_error_code(), target);
  }

  // optional string text = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.GenericReply.text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.GenericReply)
  return target;
}

size_t GenericReply::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.GenericReply)
  size_t total_size = 0;

  if (_internal_has_request_id()) {
    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }

  if (_internal_has_error_code()) {
    // required uint32 error_code = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());
  }

  return total_size;
}
size_t GenericReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.GenericReply)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());

    // required uint32 error_code = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string text = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenericReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GenericReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenericReply::GetClassData() const { return &_class_data_; }


void GenericReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GenericReply*>(&to_msg);
  auto& from = static_cast<const GenericReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.GenericReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenericReply::CopyFrom(const GenericReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.GenericReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericReply::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GenericReply::InternalSwap(GenericReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericReply, _impl_.error_code_)
      + sizeof(GenericReply::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(GenericReply, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GenericReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[1]);
}

// ===================================================================

class InsertLimitOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertLimitOrder>()._impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ProtoCommon::Instrument& instrument(const InsertLimitOrder* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

const ::ProtoCommon::Instrument&
InsertLimitOrder::_Internal::instrument(const InsertLimitOrder* msg) {
  return *msg->_impl_.instrument_;
}
InsertLimitOrder::InsertLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.InsertLimitOrder)
}
InsertLimitOrder::InsertLimitOrder(const InsertLimitOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertLimitOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.side_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.price_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  ::memcpy(&_impl_.request_id_, &from._impl_.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.price_) -
    reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.price_));
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.InsertLimitOrder)
}

inline void InsertLimitOrder::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.request_id_){0u}
    , decltype(_impl_.side_){0}
    , decltype(_impl_.volume_){uint64_t{0u}}
    , decltype(_impl_.price_){int64_t{0}}
  };
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InsertLimitOrder::~InsertLimitOrder() {
  // @@protoc_insertion_point(destructor:ProtoCommon.InsertLimitOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertLimitOrder::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void InsertLimitOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertLimitOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.InsertLimitOrder)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
      _impl_.instrument_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.price_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.price_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertLimitOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Instrument instrument = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string account_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.InsertLimitOrder.account_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 volume = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 price = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Side side = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ProtoCommon::Side_IsValid(val))) {
            _internal_set_side(static_cast<::ProtoCommon::Side>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertLimitOrder::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.InsertLimitOrder)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  // required .ProtoCommon.Instrument instrument = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required string account_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.InsertLimitOrder.account_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_account_name(), target);
  }

  // required uint64 volume = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_volume(), target);
  }

  // required int64 price = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_price(), target);
  }

  // required .ProtoCommon.Side side = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.InsertLimitOrder)
  return target;
}

size_t InsertLimitOrder::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.InsertLimitOrder)
  size_t total_size = 0;

  if (_internal_has_account_name()) {
    // required string account_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());
  }

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_request_id()) {
    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }

  if (_internal_has_side()) {
    // required .ProtoCommon.Side side = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  if (_internal_has_volume()) {
    // required uint64 volume = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());
  }

  if (_internal_has_price()) {
    // required int64 price = 5;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());
  }

  return total_size;
}
size_t InsertLimitOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.InsertLimitOrder)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required string account_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());

    // required .ProtoCommon.Instrument instrument = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());

    // required .ProtoCommon.Side side = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());

    // required uint64 volume = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());

    // required int64 price = 5;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertLimitOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertLimitOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertLimitOrder::GetClassData() const { return &_class_data_; }


void InsertLimitOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertLimitOrder*>(&to_msg);
  auto& from = static_cast<const InsertLimitOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.InsertLimitOrder)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertLimitOrder::CopyFrom(const InsertLimitOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.InsertLimitOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertLimitOrder::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void InsertLimitOrder::InternalSwap(InsertLimitOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_name_, lhs_arena,
      &other->_impl_.account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertLimitOrder, _impl_.price_)
      + sizeof(InsertLimitOrder::_impl_.price_)
      - PROTOBUF_FIELD_OFFSET(InsertLimitOrder, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertLimitOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[2]);
}

// ===================================================================

class InsertMarketOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertMarketOrder>()._impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ProtoCommon::Instrument& instrument(const InsertMarketOrder* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::ProtoCommon::Instrument&
InsertMarketOrder::_Internal::instrument(const InsertMarketOrder* msg) {
  return *msg->_impl_.instrument_;
}
InsertMarketOrder::InsertMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.InsertMarketOrder)
}
InsertMarketOrder::InsertMarketOrder(const InsertMarketOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertMarketOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.side_){}
    , decltype(_impl_.volume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  ::memcpy(&_impl_.request_id_, &from._impl_.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.volume_) -
    reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.volume_));
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.InsertMarketOrder)
}

inline void InsertMarketOrder::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.request_id_){0u}
    , decltype(_impl_.side_){0}
    , decltype(_impl_.volume_){uint64_t{0u}}
  };
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InsertMarketOrder::~InsertMarketOrder() {
  // @@protoc_insertion_point(destructor:ProtoCommon.InsertMarketOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertMarketOrder::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void InsertMarketOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertMarketOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.InsertMarketOrder)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
      _impl_.instrument_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.volume_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.volume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertMarketOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Instrument instrument = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string account_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.InsertMarketOrder.account_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 volume = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Side side = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ProtoCommon::Side_IsValid(val))) {
            _internal_set_side(static_cast<::ProtoCommon::Side>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertMarketOrder::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.InsertMarketOrder)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  // required .ProtoCommon.Instrument instrument = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required string account_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.InsertMarketOrder.account_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_account_name(), target);
  }

  // required uint64 volume = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_volume(), target);
  }

  // required .ProtoCommon.Side side = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.InsertMarketOrder)
  return target;
}

size_t InsertMarketOrder::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.InsertMarketOrder)
  size_t total_size = 0;

  if (_internal_has_account_name()) {
    // required string account_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());
  }

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_request_id()) {
    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }

  if (_internal_has_side()) {
    // required .ProtoCommon.Side side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  if (_internal_has_volume()) {
    // required uint64 volume = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());
  }

  return total_size;
}
size_t InsertMarketOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.InsertMarketOrder)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string account_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());

    // required .ProtoCommon.Instrument instrument = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());

    // required .ProtoCommon.Side side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());

    // required uint64 volume = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertMarketOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertMarketOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertMarketOrder::GetClassData() const { return &_class_data_; }


void InsertMarketOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertMarketOrder*>(&to_msg);
  auto& from = static_cast<const InsertMarketOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.InsertMarketOrder)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertMarketOrder::CopyFrom(const InsertMarketOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.InsertMarketOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertMarketOrder::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void InsertMarketOrder::InternalSwap(InsertMarketOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_name_, lhs_arena,
      &other->_impl_.account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertMarketOrder, _impl_.volume_)
      + sizeof(InsertMarketOrder::_impl_.volume_)
      - PROTOBUF_FIELD_OFFSET(InsertMarketOrder, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertMarketOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[3]);
}

// ===================================================================

class CancelOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<CancelOrder>()._impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ProtoCommon::Instrument& instrument(const CancelOrder* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::ProtoCommon::Instrument&
CancelOrder::_Internal::instrument(const CancelOrder* msg) {
  return *msg->_impl_.instrument_;
}
CancelOrder::CancelOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.CancelOrder)
}
CancelOrder::CancelOrder(const CancelOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CancelOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.side_){}
    , decltype(_impl_.price_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  ::memcpy(&_impl_.request_id_, &from._impl_.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.price_) -
    reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.price_));
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.CancelOrder)
}

inline void CancelOrder::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.request_id_){0u}
    , decltype(_impl_.side_){0}
    , decltype(_impl_.price_){int64_t{0}}
  };
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CancelOrder::~CancelOrder() {
  // @@protoc_insertion_point(destructor:ProtoCommon.CancelOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CancelOrder::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void CancelOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CancelOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.CancelOrder)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
      _impl_.instrument_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.price_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.price_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CancelOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Instrument instrument = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string account_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.CancelOrder.account_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 price = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Side side = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ProtoCommon::Side_IsValid(val))) {
            _internal_set_side(static_cast<::ProtoCommon::Side>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CancelOrder::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.CancelOrder)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  // required .ProtoCommon.Instrument instrument = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required string account_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.CancelOrder.account_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_account_name(), target);
  }

  // required int64 price = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_price(), target);
  }

  // required .ProtoCommon.Side side = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.CancelOrder)
  return target;
}

size_t CancelOrder::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.CancelOrder)
  size_t total_size = 0;

  if (_internal_has_account_name()) {
    // required string account_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());
  }

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_request_id()) {
    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }

  if (_internal_has_side()) {
    // required .ProtoCommon.Side side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  if (_internal_has_price()) {
    // required int64 price = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());
  }

  return total_size;
}
size_t CancelOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.CancelOrder)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string account_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());

    // required .ProtoCommon.Instrument instrument = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required uint32 request_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());

    // required .ProtoCommon.Side side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());

    // required int64 price = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CancelOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CancelOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CancelOrder::GetClassData() const { return &_class_data_; }


void CancelOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CancelOrder*>(&to_msg);
  auto& from = static_cast<const CancelOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.CancelOrder)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CancelOrder::CopyFrom(const CancelOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.CancelOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelOrder::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void CancelOrder::InternalSwap(CancelOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_name_, lhs_arena,
      &other->_impl_.account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CancelOrder, _impl_.price_)
      + sizeof(CancelOrder::_impl_.price_)
      - PROTOBUF_FIELD_OFFSET(CancelOrder, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CancelOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[4]);
}

// ===================================================================

class LevelUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<LevelUpdate>()._impl_._has_bits_);
  static const ::ProtoCommon::Instrument& instrument(const LevelUpdate* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_side(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::ProtoCommon::Instrument&
LevelUpdate::_Internal::instrument(const LevelUpdate* msg) {
  return *msg->_impl_.instrument_;
}
LevelUpdate::LevelUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.LevelUpdate)
}
LevelUpdate::LevelUpdate(const LevelUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LevelUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.side_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  ::memcpy(&_impl_.volume_, &from._impl_.volume_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.side_) -
    reinterpret_cast<char*>(&_impl_.volume_)) + sizeof(_impl_.side_));
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.LevelUpdate)
}

inline void LevelUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.volume_){uint64_t{0u}}
    , decltype(_impl_.price_){int64_t{0}}
    , decltype(_impl_.side_){0}
  };
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LevelUpdate::~LevelUpdate() {
  // @@protoc_insertion_point(destructor:ProtoCommon.LevelUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LevelUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void LevelUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LevelUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.LevelUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
      _impl_.instrument_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.volume_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.side_) -
        reinterpret_cast<char*>(&_impl_.volume_)) + sizeof(_impl_.side_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LevelUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ProtoCommon.Instrument instrument = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string account_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.LevelUpdate.account_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 volume = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 price = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Side side = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ProtoCommon::Side_IsValid(val))) {
            _internal_set_side(static_cast<::ProtoCommon::Side>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LevelUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.LevelUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .ProtoCommon.Instrument instrument = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required string account_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.LevelUpdate.account_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_name(), target);
  }

  // required uint64 volume = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_volume(), target);
  }

  // required int64 price = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_price(), target);
  }

  // required .ProtoCommon.Side side = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.LevelUpdate)
  return target;
}

size_t LevelUpdate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.LevelUpdate)
  size_t total_size = 0;

  if (_internal_has_account_name()) {
    // required string account_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());
  }

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_volume()) {
    // required uint64 volume = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());
  }

  if (_internal_has_price()) {
    // required int64 price = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());
  }

  if (_internal_has_side()) {
    // required .ProtoCommon.Side side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  return total_size;
}
size_t LevelUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.LevelUpdate)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string account_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());

    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required uint64 volume = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());

    // required int64 price = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());

    // required .ProtoCommon.Side side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LevelUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LevelUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LevelUpdate::GetClassData() const { return &_class_data_; }


void LevelUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LevelUpdate*>(&to_msg);
  auto& from = static_cast<const LevelUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.LevelUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.side_ = from._impl_.side_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LevelUpdate::CopyFrom(const LevelUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.LevelUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LevelUpdate::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void LevelUpdate::InternalSwap(LevelUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_name_, lhs_arena,
      &other->_impl_.account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LevelUpdate, _impl_.side_)
      + sizeof(LevelUpdate::_impl_.side_)
      - PROTOBUF_FIELD_OFFSET(LevelUpdate, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LevelUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[5]);
}

// ===================================================================

class Trade::_Internal {
 public:
  using HasBits = decltype(std::declval<Trade>()._impl_._has_bits_);
  static const ::ProtoCommon::Instrument& instrument(const Trade* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_passive_account(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_passive_side(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::ProtoCommon::Instrument&
Trade::_Internal::instrument(const Trade* msg) {
  return *msg->_impl_.instrument_;
}
Trade::Trade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.Trade)
}
Trade::Trade(const Trade& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Trade* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.passive_account_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.passive_side_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.passive_account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.passive_account_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_passive_account()) {
    _this->_impl_.passive_account_.Set(from._internal_passive_account(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  ::memcpy(&_impl_.volume_, &from._impl_.volume_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.passive_side_) -
    reinterpret_cast<char*>(&_impl_.volume_)) + sizeof(_impl_.passive_side_));
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.Trade)
}

inline void Trade::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.passive_account_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.volume_){uint64_t{0u}}
    , decltype(_impl_.price_){int64_t{0}}
    , decltype(_impl_.passive_side_){0}
  };
  _impl_.passive_account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.passive_account_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Trade::~Trade() {
  // @@protoc_insertion_point(destructor:ProtoCommon.Trade)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Trade::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.passive_account_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void Trade::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Trade::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.Trade)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.passive_account_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
      _impl_.instrument_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.volume_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.passive_side_) -
        reinterpret_cast<char*>(&_impl_.volume_)) + sizeof(_impl_.passive_side_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Trade::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ProtoCommon.Instrument instrument = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 volume = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 price = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string passive_account = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_passive_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.Trade.passive_account");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required .ProtoCommon.Side passive_side = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ProtoCommon::Side_IsValid(val))) {
            _internal_set_passive_side(static_cast<::ProtoCommon::Side>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trade::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.Trade)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .ProtoCommon.Instrument instrument = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required uint64 volume = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_volume(), target);
  }

  // required int64 price = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_price(), target);
  }

  // required string passive_account = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_passive_account().data(), static_cast<int>(this->_internal_passive_account().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.Trade.passive_account");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_passive_account(), target);
  }

  // required .ProtoCommon.Side passive_side = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_passive_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.Trade)
  return target;
}

size_t Trade::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.Trade)
  size_t total_size = 0;

  if (_internal_has_passive_account()) {
    // required string passive_account = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_passive_account());
  }

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_volume()) {
    // required uint64 volume = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());
  }

  if (_internal_has_price()) {
    // required int64 price = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());
  }

  if (_internal_has_passive_side()) {
    // required .ProtoCommon.Side passive_side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_passive_side());
  }

  return total_size;
}
size_t Trade::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.Trade)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string passive_account = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_passive_account());

    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required uint64 volume = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_volume());

    // required int64 price = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());

    // required .ProtoCommon.Side passive_side = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_passive_side());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Trade::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Trade::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Trade::GetClassData() const { return &_class_data_; }


void Trade::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Trade*>(&to_msg);
  auto& from = static_cast<const Trade&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.Trade)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_passive_account(from._internal_passive_account());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.passive_side_ = from._impl_.passive_side_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Trade::CopyFrom(const Trade& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.Trade)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trade::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void Trade::InternalSwap(Trade* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.passive_account_, lhs_arena,
      &other->_impl_.passive_account_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Trade, _impl_.passive_side_)
      + sizeof(Trade::_impl_.passive_side_)
      - PROTOBUF_FIELD_OFFSET(Trade, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Trade::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[6]);
}

// ===================================================================

class CreateMarket::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateMarket>()._impl_._has_bits_);
  static const ::ProtoCommon::Instrument& instrument(const CreateMarket* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_settlement_price(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::ProtoCommon::Instrument&
CreateMarket::_Internal::instrument(const CreateMarket* msg) {
  return *msg->_impl_.instrument_;
}
CreateMarket::CreateMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.CreateMarket)
}
CreateMarket::CreateMarket(const CreateMarket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateMarket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){from._impl_.user_name_}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.settlement_price_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  _this->_impl_.settlement_price_ = from._impl_.settlement_price_;
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.CreateMarket)
}

inline void CreateMarket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_name_){arena}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.settlement_price_){int64_t{0}}
  };
}

CreateMarket::~CreateMarket() {
  // @@protoc_insertion_point(destructor:ProtoCommon.CreateMarket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateMarket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_name_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void CreateMarket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateMarket::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.CreateMarket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_name_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
    _impl_.instrument_->Clear();
  }
  _impl_.settlement_price_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateMarket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ProtoCommon.Instrument instrument = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 settlement_price = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_settlement_price(&has_bits);
          _impl_.settlement_price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string user_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_user_name();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ProtoCommon.CreateMarket.user_name");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateMarket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.CreateMarket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .ProtoCommon.Instrument instrument = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required int64 settlement_price = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_settlement_price(), target);
  }

  // repeated string user_name = 3;
  for (int i = 0, n = this->_internal_user_name_size(); i < n; i++) {
    const auto& s = this->_internal_user_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.CreateMarket.user_name");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.CreateMarket)
  return target;
}

size_t CreateMarket::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.CreateMarket)
  size_t total_size = 0;

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_settlement_price()) {
    // required int64 settlement_price = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_settlement_price());
  }

  return total_size;
}
size_t CreateMarket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.CreateMarket)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required int64 settlement_price = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_settlement_price());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string user_name = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.user_name_.size());
  for (int i = 0, n = _impl_.user_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.user_name_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateMarket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateMarket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateMarket::GetClassData() const { return &_class_data_; }


void CreateMarket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateMarket*>(&to_msg);
  auto& from = static_cast<const CreateMarket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.CreateMarket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_name_.MergeFrom(from._impl_.user_name_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.settlement_price_ = from._impl_.settlement_price_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateMarket::CopyFrom(const CreateMarket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.CreateMarket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateMarket::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void CreateMarket::InternalSwap(CreateMarket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.user_name_.InternalSwap(&other->_impl_.user_name_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateMarket, _impl_.settlement_price_)
      + sizeof(CreateMarket::_impl_.settlement_price_)
      - PROTOBUF_FIELD_OFFSET(CreateMarket, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateMarket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[7]);
}

// ===================================================================

class CreateMarketReply::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateMarketReply>()._impl_._has_bits_);
  static const ::ProtoCommon::Instrument& instrument(const CreateMarketReply* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::ProtoCommon::Instrument&
CreateMarketReply::_Internal::instrument(const CreateMarketReply* msg) {
  return *msg->_impl_.instrument_;
}
CreateMarketReply::CreateMarketReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.CreateMarketReply)
}
CreateMarketReply::CreateMarketReply(const CreateMarketReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateMarketReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.error_code_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  _this->_impl_.error_code_ = from._impl_.error_code_;
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.CreateMarketReply)
}

inline void CreateMarketReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.error_code_){0u}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateMarketReply::~CreateMarketReply() {
  // @@protoc_insertion_point(destructor:ProtoCommon.CreateMarketReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateMarketReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void CreateMarketReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateMarketReply::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.CreateMarketReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
      _impl_.instrument_->Clear();
    }
  }
  _impl_.error_code_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateMarketReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ProtoCommon.Instrument instrument = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_error_code(&has_bits);
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.CreateMarketReply.text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateMarketReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.CreateMarketReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .ProtoCommon.Instrument instrument = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required uint32 error_code = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_error_code(), target);
  }

  // optional string text = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.CreateMarketReply.text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.CreateMarketReply)
  return target;
}

size_t CreateMarketReply::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.CreateMarketReply)
  size_t total_size = 0;

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_error_code()) {
    // required uint32 error_code = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());
  }

  return total_size;
}
size_t CreateMarketReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.CreateMarketReply)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required uint32 error_code = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string text = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateMarketReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateMarketReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateMarketReply::GetClassData() const { return &_class_data_; }


void CreateMarketReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateMarketReply*>(&to_msg);
  auto& from = static_cast<const CreateMarketReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.CreateMarketReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateMarketReply::CopyFrom(const CreateMarketReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.CreateMarketReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateMarketReply::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void CreateMarketReply::InternalSwap(CreateMarketReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateMarketReply, _impl_.error_code_)
      + sizeof(CreateMarketReply::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(CreateMarketReply, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateMarketReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[8]);
}

// ===================================================================

class PositionUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<PositionUpdate>()._impl_._has_bits_);
  static const ::ProtoCommon::Instrument& instrument(const PositionUpdate* msg);
  static void set_has_instrument(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::ProtoCommon::Instrument&
PositionUpdate::_Internal::instrument(const PositionUpdate* msg) {
  return *msg->_impl_.instrument_;
}
PositionUpdate::PositionUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.PositionUpdate)
}
PositionUpdate::PositionUpdate(const PositionUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PositionUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.position_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instrument()) {
    _this->_impl_.instrument_ = new ::ProtoCommon::Instrument(*from._impl_.instrument_);
  }
  _this->_impl_.position_ = from._impl_.position_;
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.PositionUpdate)
}

inline void PositionUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.instrument_){nullptr}
    , decltype(_impl_.position_){int64_t{0}}
  };
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PositionUpdate::~PositionUpdate() {
  // @@protoc_insertion_point(destructor:ProtoCommon.PositionUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PositionUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instrument_;
}

void PositionUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PositionUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.PositionUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instrument_ != nullptr);
      _impl_.instrument_->Clear();
    }
  }
  _impl_.position_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PositionUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ProtoCommon.Instrument instrument = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_instrument(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string account_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ProtoCommon.PositionUpdate.account_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PositionUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.PositionUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .ProtoCommon.Instrument instrument = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::instrument(this),
        _Internal::instrument(this).GetCachedSize(), target, stream);
  }

  // required string account_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ProtoCommon.PositionUpdate.account_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_name(), target);
  }

  // required int64 position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_position(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.PositionUpdate)
  return target;
}

size_t PositionUpdate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ProtoCommon.PositionUpdate)
  size_t total_size = 0;

  if (_internal_has_account_name()) {
    // required string account_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());
  }

  if (_internal_has_instrument()) {
    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);
  }

  if (_internal_has_position()) {
    // required int64 position = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_position());
  }

  return total_size;
}
size_t PositionUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.PositionUpdate)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string account_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());

    // required .ProtoCommon.Instrument instrument = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instrument_);

    // required int64 position = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_position());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PositionUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PositionUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PositionUpdate::GetClassData() const { return &_class_data_; }


void PositionUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PositionUpdate*>(&to_msg);
  auto& from = static_cast<const PositionUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.PositionUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instrument()->::ProtoCommon::Instrument::MergeFrom(
          from._internal_instrument());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PositionUpdate::CopyFrom(const PositionUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.PositionUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionUpdate::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_instrument()) {
    if (!_impl_.instrument_->IsInitialized()) return false;
  }
  return true;
}

void PositionUpdate::InternalSwap(PositionUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_name_, lhs_arena,
      &other->_impl_.account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionUpdate, _impl_.position_)
      + sizeof(PositionUpdate::_impl_.position_)
      - PROTOBUF_FIELD_OFFSET(PositionUpdate, _impl_.instrument_)>(
          reinterpret_cast<char*>(&_impl_.instrument_),
          reinterpret_cast<char*>(&other->_impl_.instrument_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PositionUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[9]);
}

// ===================================================================

class Message::_Internal {
 public:
  using HasBits = decltype(std::declval<Message>()._impl_._has_bits_);
  static const ::ProtoCommon::InsertLimitOrder& insert_limit_order(const Message* msg);
  static void set_has_insert_limit_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ProtoCommon::InsertMarketOrder& insert_market_order(const Message* msg);
  static void set_has_insert_market_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ProtoCommon::CancelOrder& cancel_order(const Message* msg);
  static void set_has_cancel_order(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ProtoCommon::LevelUpdate& level_update(const Message* msg);
  static void set_has_level_update(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ProtoCommon::Trade& trade(const Message* msg);
  static void set_has_trade(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::ProtoCommon::CreateMarket& create_market(const Message* msg);
  static void set_has_create_market(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::ProtoCommon::CreateMarketReply& create_market_reply(const Message* msg);
  static void set_has_create_market_reply(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::ProtoCommon::PositionUpdate& position_update(const Message* msg);
  static void set_has_position_update(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::ProtoCommon::InsertLimitOrder&
Message::_Internal::insert_limit_order(const Message* msg) {
  return *msg->_impl_.insert_limit_order_;
}
const ::ProtoCommon::InsertMarketOrder&
Message::_Internal::insert_market_order(const Message* msg) {
  return *msg->_impl_.insert_market_order_;
}
const ::ProtoCommon::CancelOrder&
Message::_Internal::cancel_order(const Message* msg) {
  return *msg->_impl_.cancel_order_;
}
const ::ProtoCommon::LevelUpdate&
Message::_Internal::level_update(const Message* msg) {
  return *msg->_impl_.level_update_;
}
const ::ProtoCommon::Trade&
Message::_Internal::trade(const Message* msg) {
  return *msg->_impl_.trade_;
}
const ::ProtoCommon::CreateMarket&
Message::_Internal::create_market(const Message* msg) {
  return *msg->_impl_.create_market_;
}
const ::ProtoCommon::CreateMarketReply&
Message::_Internal::create_market_reply(const Message* msg) {
  return *msg->_impl_.create_market_reply_;
}
const ::ProtoCommon::PositionUpdate&
Message::_Internal::position_update(const Message* msg) {
  return *msg->_impl_.position_update_;
}
Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoCommon.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){from._impl_.type_}
    , decltype(_impl_.insert_limit_order_){nullptr}
    , decltype(_impl_.insert_market_order_){nullptr}
    , decltype(_impl_.cancel_order_){nullptr}
    , decltype(_impl_.level_update_){nullptr}
    , decltype(_impl_.trade_){nullptr}
    , decltype(_impl_.create_market_){nullptr}
    , decltype(_impl_.create_market_reply_){nullptr}
    , decltype(_impl_.position_update_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_insert_limit_order()) {
    _this->_impl_.insert_limit_order_ = new ::ProtoCommon::InsertLimitOrder(*from._impl_.insert_limit_order_);
  }
  if (from._internal_has_insert_market_order()) {
    _this->_impl_.insert_market_order_ = new ::ProtoCommon::InsertMarketOrder(*from._impl_.insert_market_order_);
  }
  if (from._internal_has_cancel_order()) {
    _this->_impl_.cancel_order_ = new ::ProtoCommon::CancelOrder(*from._impl_.cancel_order_);
  }
  if (from._internal_has_level_update()) {
    _this->_impl_.level_update_ = new ::ProtoCommon::LevelUpdate(*from._impl_.level_update_);
  }
  if (from._internal_has_trade()) {
    _this->_impl_.trade_ = new ::ProtoCommon::Trade(*from._impl_.trade_);
  }
  if (from._internal_has_create_market()) {
    _this->_impl_.create_market_ = new ::ProtoCommon::CreateMarket(*from._impl_.create_market_);
  }
  if (from._internal_has_create_market_reply()) {
    _this->_impl_.create_market_reply_ = new ::ProtoCommon::CreateMarketReply(*from._impl_.create_market_reply_);
  }
  if (from._internal_has_position_update()) {
    _this->_impl_.position_update_ = new ::ProtoCommon::PositionUpdate(*from._impl_.position_update_);
  }
  // @@protoc_insertion_point(copy_constructor:ProtoCommon.Message)
}

inline void Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){arena}
    , decltype(_impl_.insert_limit_order_){nullptr}
    , decltype(_impl_.insert_market_order_){nullptr}
    , decltype(_impl_.cancel_order_){nullptr}
    , decltype(_impl_.level_update_){nullptr}
    , decltype(_impl_.trade_){nullptr}
    , decltype(_impl_.create_market_){nullptr}
    , decltype(_impl_.create_market_reply_){nullptr}
    , decltype(_impl_.position_update_){nullptr}
  };
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:ProtoCommon.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.insert_limit_order_;
  if (this != internal_default_instance()) delete _impl_.insert_market_order_;
  if (this != internal_default_instance()) delete _impl_.cancel_order_;
  if (this != internal_default_instance()) delete _impl_.level_update_;
  if (this != internal_default_instance()) delete _impl_.trade_;
  if (this != internal_default_instance()) delete _impl_.create_market_;
  if (this != internal_default_instance()) delete _impl_.create_market_reply_;
  if (this != internal_default_instance()) delete _impl_.position_update_;
}

void Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoCommon.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.insert_limit_order_ != nullptr);
      _impl_.insert_limit_order_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.insert_market_order_ != nullptr);
      _impl_.insert_market_order_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cancel_order_ != nullptr);
      _impl_.cancel_order_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.level_update_ != nullptr);
      _impl_.level_update_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.trade_ != nullptr);
      _impl_.trade_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.create_market_ != nullptr);
      _impl_.create_market_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.create_market_reply_ != nullptr);
      _impl_.create_market_reply_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.position_update_ != nullptr);
      _impl_.position_update_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ProtoCommon.MessageType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ProtoCommon::MessageType_IsValid(val))) {
              _internal_add_type(static_cast<::ProtoCommon::MessageType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_type(), ptr, ctx, ::ProtoCommon::MessageType_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.InsertLimitOrder insert_limit_order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_insert_limit_order(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.InsertMarketOrder insert_market_order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_insert_market_order(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.CancelOrder cancel_order = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cancel_order(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.LevelUpdate level_update = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_level_update(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.Trade trade = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_trade(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.CreateMarket create_market = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_market(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.CreateMarketReply create_market_reply = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_market_reply(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ProtoCommon.PositionUpdate position_update = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_position_update(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoCommon.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ProtoCommon.MessageType type = 1;
  for (int i = 0, n = this->_internal_type_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .ProtoCommon.InsertLimitOrder insert_limit_order = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::insert_limit_order(this),
        _Internal::insert_limit_order(this).GetCachedSize(), target, stream);
  }

  // optional .ProtoCommon.InsertMarketOrder insert_market_order = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::insert_market_order(this),
        _Internal::insert_market_order(this).GetCachedSize(), target, stream);
  }

  // optional .ProtoCommon.CancelOrder cancel_order = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::cancel_order(this),
        _Internal::cancel_order(this).GetCachedSize(), target, stream);
  }

  // optional .ProtoCommon.LevelUpdate level_update = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::level_update(this),
        _Internal::level_update(this).GetCachedSize(), target, stream);
  }

  // optional .ProtoCommon.Trade trade = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::trade(this),
        _Internal::trade(this).GetCachedSize(), target, stream);
  }

  // optional .ProtoCommon.CreateMarket create_market = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::create_market(this),
        _Internal::create_market(this).GetCachedSize(), target, stream);
  }

  // optional .ProtoCommon.CreateMarketReply create_market_reply = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::create_market_reply(this),
        _Internal::create_market_reply(this).GetCachedSize(), target, stream);
  }

  // optional .ProtoCommon.PositionUpdate position_update = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::position_update(this),
        _Internal::position_update(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoCommon.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoCommon.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ProtoCommon.MessageType type = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_type_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_type(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ProtoCommon.InsertLimitOrder insert_limit_order = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.insert_limit_order_);
    }

    // optional .ProtoCommon.InsertMarketOrder insert_market_order = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.insert_market_order_);
    }

    // optional .ProtoCommon.CancelOrder cancel_order = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cancel_order_);
    }

    // optional .ProtoCommon.LevelUpdate level_update = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.level_update_);
    }

    // optional .ProtoCommon.Trade trade = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trade_);
    }

    // optional .ProtoCommon.CreateMarket create_market = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.create_market_);
    }

    // optional .ProtoCommon.CreateMarketReply create_market_reply = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.create_market_reply_);
    }

    // optional .ProtoCommon.PositionUpdate position_update = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_update_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }


void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message*>(&to_msg);
  auto& from = static_cast<const Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoCommon.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.type_.MergeFrom(from._impl_.type_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_insert_limit_order()->::ProtoCommon::InsertLimitOrder::MergeFrom(
          from._internal_insert_limit_order());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_insert_market_order()->::ProtoCommon::InsertMarketOrder::MergeFrom(
          from._internal_insert_market_order());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cancel_order()->::ProtoCommon::CancelOrder::MergeFrom(
          from._internal_cancel_order());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_level_update()->::ProtoCommon::LevelUpdate::MergeFrom(
          from._internal_level_update());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_trade()->::ProtoCommon::Trade::MergeFrom(
          from._internal_trade());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_create_market()->::ProtoCommon::CreateMarket::MergeFrom(
          from._internal_create_market());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_create_market_reply()->::ProtoCommon::CreateMarketReply::MergeFrom(
          from._internal_create_market_reply());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_position_update()->::ProtoCommon::PositionUpdate::MergeFrom(
          from._internal_position_update());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoCommon.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  if (_internal_has_insert_limit_order()) {
    if (!_impl_.insert_limit_order_->IsInitialized()) return false;
  }
  if (_internal_has_insert_market_order()) {
    if (!_impl_.insert_market_order_->IsInitialized()) return false;
  }
  if (_internal_has_cancel_order()) {
    if (!_impl_.cancel_order_->IsInitialized()) return false;
  }
  if (_internal_has_level_update()) {
    if (!_impl_.level_update_->IsInitialized()) return false;
  }
  if (_internal_has_trade()) {
    if (!_impl_.trade_->IsInitialized()) return false;
  }
  if (_internal_has_create_market()) {
    if (!_impl_.create_market_->IsInitialized()) return false;
  }
  if (_internal_has_create_market_reply()) {
    if (!_impl_.create_market_reply_->IsInitialized()) return false;
  }
  if (_internal_has_position_update()) {
    if (!_impl_.position_update_->IsInitialized()) return false;
  }
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.type_.InternalSwap(&other->_impl_.type_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message, _impl_.position_update_)
      + sizeof(Message::_impl_.position_update_)
      - PROTOBUF_FIELD_OFFSET(Message, _impl_.insert_limit_order_)>(
          reinterpret_cast<char*>(&_impl_.insert_limit_order_),
          reinterpret_cast<char*>(&other->_impl_.insert_limit_order_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2eproto_getter, &descriptor_table_common_2eproto_once,
      file_level_metadata_common_2eproto[10]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace ProtoCommon
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ProtoCommon::Instrument*
Arena::CreateMaybeMessage< ::ProtoCommon::Instrument >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::Instrument >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::GenericReply*
Arena::CreateMaybeMessage< ::ProtoCommon::GenericReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::GenericReply >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::InsertLimitOrder*
Arena::CreateMaybeMessage< ::ProtoCommon::InsertLimitOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::InsertLimitOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::InsertMarketOrder*
Arena::CreateMaybeMessage< ::ProtoCommon::InsertMarketOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::InsertMarketOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::CancelOrder*
Arena::CreateMaybeMessage< ::ProtoCommon::CancelOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::CancelOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::LevelUpdate*
Arena::CreateMaybeMessage< ::ProtoCommon::LevelUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::LevelUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::Trade*
Arena::CreateMaybeMessage< ::ProtoCommon::Trade >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::Trade >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::CreateMarket*
Arena::CreateMaybeMessage< ::ProtoCommon::CreateMarket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::CreateMarket >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::CreateMarketReply*
Arena::CreateMaybeMessage< ::ProtoCommon::CreateMarketReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::CreateMarketReply >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::PositionUpdate*
Arena::CreateMaybeMessage< ::ProtoCommon::PositionUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::PositionUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoCommon::Message*
Arena::CreateMaybeMessage< ::ProtoCommon::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoCommon::Message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
