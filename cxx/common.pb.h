// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
namespace ProtoCommon {
class CancelOrder;
struct CancelOrderDefaultTypeInternal;
extern CancelOrderDefaultTypeInternal _CancelOrder_default_instance_;
class CreateMarket;
struct CreateMarketDefaultTypeInternal;
extern CreateMarketDefaultTypeInternal _CreateMarket_default_instance_;
class CreateMarketReply;
struct CreateMarketReplyDefaultTypeInternal;
extern CreateMarketReplyDefaultTypeInternal _CreateMarketReply_default_instance_;
class GenericReply;
struct GenericReplyDefaultTypeInternal;
extern GenericReplyDefaultTypeInternal _GenericReply_default_instance_;
class InsertLimitOrder;
struct InsertLimitOrderDefaultTypeInternal;
extern InsertLimitOrderDefaultTypeInternal _InsertLimitOrder_default_instance_;
class InsertMarketOrder;
struct InsertMarketOrderDefaultTypeInternal;
extern InsertMarketOrderDefaultTypeInternal _InsertMarketOrder_default_instance_;
class Instrument;
struct InstrumentDefaultTypeInternal;
extern InstrumentDefaultTypeInternal _Instrument_default_instance_;
class LevelUpdate;
struct LevelUpdateDefaultTypeInternal;
extern LevelUpdateDefaultTypeInternal _LevelUpdate_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class PositionUpdate;
struct PositionUpdateDefaultTypeInternal;
extern PositionUpdateDefaultTypeInternal _PositionUpdate_default_instance_;
class Trade;
struct TradeDefaultTypeInternal;
extern TradeDefaultTypeInternal _Trade_default_instance_;
}  // namespace ProtoCommon
PROTOBUF_NAMESPACE_OPEN
template<> ::ProtoCommon::CancelOrder* Arena::CreateMaybeMessage<::ProtoCommon::CancelOrder>(Arena*);
template<> ::ProtoCommon::CreateMarket* Arena::CreateMaybeMessage<::ProtoCommon::CreateMarket>(Arena*);
template<> ::ProtoCommon::CreateMarketReply* Arena::CreateMaybeMessage<::ProtoCommon::CreateMarketReply>(Arena*);
template<> ::ProtoCommon::GenericReply* Arena::CreateMaybeMessage<::ProtoCommon::GenericReply>(Arena*);
template<> ::ProtoCommon::InsertLimitOrder* Arena::CreateMaybeMessage<::ProtoCommon::InsertLimitOrder>(Arena*);
template<> ::ProtoCommon::InsertMarketOrder* Arena::CreateMaybeMessage<::ProtoCommon::InsertMarketOrder>(Arena*);
template<> ::ProtoCommon::Instrument* Arena::CreateMaybeMessage<::ProtoCommon::Instrument>(Arena*);
template<> ::ProtoCommon::LevelUpdate* Arena::CreateMaybeMessage<::ProtoCommon::LevelUpdate>(Arena*);
template<> ::ProtoCommon::Message* Arena::CreateMaybeMessage<::ProtoCommon::Message>(Arena*);
template<> ::ProtoCommon::PositionUpdate* Arena::CreateMaybeMessage<::ProtoCommon::PositionUpdate>(Arena*);
template<> ::ProtoCommon::Trade* Arena::CreateMaybeMessage<::ProtoCommon::Trade>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ProtoCommon {

enum MessageType : int {
  GENERIC_REPLY = 0,
  INSERT_LIMIT_ORDER = 1,
  INSERT_MARKET_ORDER = 2,
  CANCEL_ORDER = 3,
  LEVEL_UPDATE = 4,
  TRADE = 5,
  CREATE_MARKET = 6,
  CREATE_MARKET_REPLY = 7,
  POSITION_UPDATE = 8
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = GENERIC_REPLY;
constexpr MessageType MessageType_MAX = POSITION_UPDATE;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum Side : int {
  BUY = 0,
  SELL = 1
};
bool Side_IsValid(int value);
constexpr Side Side_MIN = BUY;
constexpr Side Side_MAX = SELL;
constexpr int Side_ARRAYSIZE = Side_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor();
template<typename T>
inline const std::string& Side_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Side>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Side_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Side_descriptor(), enum_t_value);
}
inline bool Side_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Side* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Side>(
    Side_descriptor(), name, value);
}
// ===================================================================

class Instrument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.Instrument) */ {
 public:
  inline Instrument() : Instrument(nullptr) {}
  ~Instrument() override;
  explicit PROTOBUF_CONSTEXPR Instrument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instrument(const Instrument& from);
  Instrument(Instrument&& from) noexcept
    : Instrument() {
    *this = ::std::move(from);
  }

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instrument& operator=(Instrument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instrument& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instrument* internal_default_instance() {
    return reinterpret_cast<const Instrument*>(
               &_Instrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Instrument& a, Instrument& b) {
    a.Swap(&b);
  }
  inline void Swap(Instrument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instrument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instrument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instrument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instrument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Instrument& from) {
    Instrument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instrument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.Instrument";
  }
  protected:
  explicit Instrument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPrecisionFieldNumber = 2,
  };
  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint64 precision = 2;
  bool has_precision() const;
  private:
  bool _internal_has_precision() const;
  public:
  void clear_precision();
  uint64_t precision() const;
  void set_precision(uint64_t value);
  private:
  uint64_t _internal_precision() const;
  void _internal_set_precision(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.Instrument)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t id_;
    uint64_t precision_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class GenericReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.GenericReply) */ {
 public:
  inline GenericReply() : GenericReply(nullptr) {}
  ~GenericReply() override;
  explicit PROTOBUF_CONSTEXPR GenericReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericReply(const GenericReply& from);
  GenericReply(GenericReply&& from) noexcept
    : GenericReply() {
    *this = ::std::move(from);
  }

  inline GenericReply& operator=(const GenericReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericReply& operator=(GenericReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericReply* internal_default_instance() {
    return reinterpret_cast<const GenericReply*>(
               &_GenericReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GenericReply& a, GenericReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenericReply& from) {
    GenericReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.GenericReply";
  }
  protected:
  explicit GenericReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // optional string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // required uint32 error_code = 2;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.GenericReply)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    uint32_t request_id_;
    uint32_t error_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class InsertLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.InsertLimitOrder) */ {
 public:
  inline InsertLimitOrder() : InsertLimitOrder(nullptr) {}
  ~InsertLimitOrder() override;
  explicit PROTOBUF_CONSTEXPR InsertLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertLimitOrder(const InsertLimitOrder& from);
  InsertLimitOrder(InsertLimitOrder&& from) noexcept
    : InsertLimitOrder() {
    *this = ::std::move(from);
  }

  inline InsertLimitOrder& operator=(const InsertLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertLimitOrder& operator=(InsertLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertLimitOrder* internal_default_instance() {
    return reinterpret_cast<const InsertLimitOrder*>(
               &_InsertLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InsertLimitOrder& a, InsertLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertLimitOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertLimitOrder& from) {
    InsertLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.InsertLimitOrder";
  }
  protected:
  explicit InsertLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 3,
    kInstrumentFieldNumber = 2,
    kRequestIdFieldNumber = 1,
    kSideFieldNumber = 6,
    kVolumeFieldNumber = 4,
    kPriceFieldNumber = 5,
  };
  // required string account_name = 3;
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // required .ProtoCommon.Instrument instrument = 2;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // required .ProtoCommon.Side side = 6;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::ProtoCommon::Side side() const;
  void set_side(::ProtoCommon::Side value);
  private:
  ::ProtoCommon::Side _internal_side() const;
  void _internal_set_side(::ProtoCommon::Side value);
  public:

  // required uint64 volume = 4;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  uint64_t volume() const;
  void set_volume(uint64_t value);
  private:
  uint64_t _internal_volume() const;
  void _internal_set_volume(uint64_t value);
  public:

  // required int64 price = 5;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  int64_t price() const;
  void set_price(int64_t value);
  private:
  int64_t _internal_price() const;
  void _internal_set_price(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.InsertLimitOrder)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::ProtoCommon::Instrument* instrument_;
    uint32_t request_id_;
    int side_;
    uint64_t volume_;
    int64_t price_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class InsertMarketOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.InsertMarketOrder) */ {
 public:
  inline InsertMarketOrder() : InsertMarketOrder(nullptr) {}
  ~InsertMarketOrder() override;
  explicit PROTOBUF_CONSTEXPR InsertMarketOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertMarketOrder(const InsertMarketOrder& from);
  InsertMarketOrder(InsertMarketOrder&& from) noexcept
    : InsertMarketOrder() {
    *this = ::std::move(from);
  }

  inline InsertMarketOrder& operator=(const InsertMarketOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertMarketOrder& operator=(InsertMarketOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertMarketOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertMarketOrder* internal_default_instance() {
    return reinterpret_cast<const InsertMarketOrder*>(
               &_InsertMarketOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InsertMarketOrder& a, InsertMarketOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertMarketOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertMarketOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertMarketOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertMarketOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertMarketOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertMarketOrder& from) {
    InsertMarketOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertMarketOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.InsertMarketOrder";
  }
  protected:
  explicit InsertMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 3,
    kInstrumentFieldNumber = 2,
    kRequestIdFieldNumber = 1,
    kSideFieldNumber = 5,
    kVolumeFieldNumber = 4,
  };
  // required string account_name = 3;
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // required .ProtoCommon.Instrument instrument = 2;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // required .ProtoCommon.Side side = 5;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::ProtoCommon::Side side() const;
  void set_side(::ProtoCommon::Side value);
  private:
  ::ProtoCommon::Side _internal_side() const;
  void _internal_set_side(::ProtoCommon::Side value);
  public:

  // required uint64 volume = 4;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  uint64_t volume() const;
  void set_volume(uint64_t value);
  private:
  uint64_t _internal_volume() const;
  void _internal_set_volume(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.InsertMarketOrder)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::ProtoCommon::Instrument* instrument_;
    uint32_t request_id_;
    int side_;
    uint64_t volume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CancelOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.CancelOrder) */ {
 public:
  inline CancelOrder() : CancelOrder(nullptr) {}
  ~CancelOrder() override;
  explicit PROTOBUF_CONSTEXPR CancelOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOrder(const CancelOrder& from);
  CancelOrder(CancelOrder&& from) noexcept
    : CancelOrder() {
    *this = ::std::move(from);
  }

  inline CancelOrder& operator=(const CancelOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOrder& operator=(CancelOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOrder* internal_default_instance() {
    return reinterpret_cast<const CancelOrder*>(
               &_CancelOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CancelOrder& a, CancelOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelOrder& from) {
    CancelOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.CancelOrder";
  }
  protected:
  explicit CancelOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 3,
    kInstrumentFieldNumber = 2,
    kRequestIdFieldNumber = 1,
    kSideFieldNumber = 5,
    kPriceFieldNumber = 4,
  };
  // required string account_name = 3;
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // required .ProtoCommon.Instrument instrument = 2;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // required .ProtoCommon.Side side = 5;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::ProtoCommon::Side side() const;
  void set_side(::ProtoCommon::Side value);
  private:
  ::ProtoCommon::Side _internal_side() const;
  void _internal_set_side(::ProtoCommon::Side value);
  public:

  // required int64 price = 4;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  int64_t price() const;
  void set_price(int64_t value);
  private:
  int64_t _internal_price() const;
  void _internal_set_price(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.CancelOrder)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::ProtoCommon::Instrument* instrument_;
    uint32_t request_id_;
    int side_;
    int64_t price_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class LevelUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.LevelUpdate) */ {
 public:
  inline LevelUpdate() : LevelUpdate(nullptr) {}
  ~LevelUpdate() override;
  explicit PROTOBUF_CONSTEXPR LevelUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LevelUpdate(const LevelUpdate& from);
  LevelUpdate(LevelUpdate&& from) noexcept
    : LevelUpdate() {
    *this = ::std::move(from);
  }

  inline LevelUpdate& operator=(const LevelUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline LevelUpdate& operator=(LevelUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LevelUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const LevelUpdate* internal_default_instance() {
    return reinterpret_cast<const LevelUpdate*>(
               &_LevelUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LevelUpdate& a, LevelUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(LevelUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LevelUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LevelUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LevelUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LevelUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LevelUpdate& from) {
    LevelUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LevelUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.LevelUpdate";
  }
  protected:
  explicit LevelUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 2,
    kInstrumentFieldNumber = 1,
    kVolumeFieldNumber = 3,
    kPriceFieldNumber = 4,
    kSideFieldNumber = 5,
  };
  // required string account_name = 2;
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // required .ProtoCommon.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required uint64 volume = 3;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  uint64_t volume() const;
  void set_volume(uint64_t value);
  private:
  uint64_t _internal_volume() const;
  void _internal_set_volume(uint64_t value);
  public:

  // required int64 price = 4;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  int64_t price() const;
  void set_price(int64_t value);
  private:
  int64_t _internal_price() const;
  void _internal_set_price(int64_t value);
  public:

  // required .ProtoCommon.Side side = 5;
  bool has_side() const;
  private:
  bool _internal_has_side() const;
  public:
  void clear_side();
  ::ProtoCommon::Side side() const;
  void set_side(::ProtoCommon::Side value);
  private:
  ::ProtoCommon::Side _internal_side() const;
  void _internal_set_side(::ProtoCommon::Side value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.LevelUpdate)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::ProtoCommon::Instrument* instrument_;
    uint64_t volume_;
    int64_t price_;
    int side_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Trade final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.Trade) */ {
 public:
  inline Trade() : Trade(nullptr) {}
  ~Trade() override;
  explicit PROTOBUF_CONSTEXPR Trade(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trade(const Trade& from);
  Trade(Trade&& from) noexcept
    : Trade() {
    *this = ::std::move(from);
  }

  inline Trade& operator=(const Trade& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trade& operator=(Trade&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trade& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trade* internal_default_instance() {
    return reinterpret_cast<const Trade*>(
               &_Trade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Trade& a, Trade& b) {
    a.Swap(&b);
  }
  inline void Swap(Trade* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trade* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trade* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trade>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trade& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Trade& from) {
    Trade::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trade* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.Trade";
  }
  protected:
  explicit Trade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassiveAccountFieldNumber = 4,
    kInstrumentFieldNumber = 1,
    kVolumeFieldNumber = 2,
    kPriceFieldNumber = 3,
    kPassiveSideFieldNumber = 5,
  };
  // required string passive_account = 4;
  bool has_passive_account() const;
  private:
  bool _internal_has_passive_account() const;
  public:
  void clear_passive_account();
  const std::string& passive_account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passive_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passive_account();
  PROTOBUF_NODISCARD std::string* release_passive_account();
  void set_allocated_passive_account(std::string* passive_account);
  private:
  const std::string& _internal_passive_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passive_account(const std::string& value);
  std::string* _internal_mutable_passive_account();
  public:

  // required .ProtoCommon.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required uint64 volume = 2;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  uint64_t volume() const;
  void set_volume(uint64_t value);
  private:
  uint64_t _internal_volume() const;
  void _internal_set_volume(uint64_t value);
  public:

  // required int64 price = 3;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  int64_t price() const;
  void set_price(int64_t value);
  private:
  int64_t _internal_price() const;
  void _internal_set_price(int64_t value);
  public:

  // required .ProtoCommon.Side passive_side = 5;
  bool has_passive_side() const;
  private:
  bool _internal_has_passive_side() const;
  public:
  void clear_passive_side();
  ::ProtoCommon::Side passive_side() const;
  void set_passive_side(::ProtoCommon::Side value);
  private:
  ::ProtoCommon::Side _internal_passive_side() const;
  void _internal_set_passive_side(::ProtoCommon::Side value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.Trade)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passive_account_;
    ::ProtoCommon::Instrument* instrument_;
    uint64_t volume_;
    int64_t price_;
    int passive_side_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CreateMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.CreateMarket) */ {
 public:
  inline CreateMarket() : CreateMarket(nullptr) {}
  ~CreateMarket() override;
  explicit PROTOBUF_CONSTEXPR CreateMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateMarket(const CreateMarket& from);
  CreateMarket(CreateMarket&& from) noexcept
    : CreateMarket() {
    *this = ::std::move(from);
  }

  inline CreateMarket& operator=(const CreateMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateMarket& operator=(CreateMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateMarket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateMarket* internal_default_instance() {
    return reinterpret_cast<const CreateMarket*>(
               &_CreateMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateMarket& a, CreateMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateMarket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateMarket& from) {
    CreateMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.CreateMarket";
  }
  protected:
  explicit CreateMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 3,
    kInstrumentFieldNumber = 1,
    kSettlementPriceFieldNumber = 2,
  };
  // repeated string user_name = 3;
  int user_name_size() const;
  private:
  int _internal_user_name_size() const;
  public:
  void clear_user_name();
  const std::string& user_name(int index) const;
  std::string* mutable_user_name(int index);
  void set_user_name(int index, const std::string& value);
  void set_user_name(int index, std::string&& value);
  void set_user_name(int index, const char* value);
  void set_user_name(int index, const char* value, size_t size);
  std::string* add_user_name();
  void add_user_name(const std::string& value);
  void add_user_name(std::string&& value);
  void add_user_name(const char* value);
  void add_user_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_name();
  private:
  const std::string& _internal_user_name(int index) const;
  std::string* _internal_add_user_name();
  public:

  // required .ProtoCommon.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required int64 settlement_price = 2;
  bool has_settlement_price() const;
  private:
  bool _internal_has_settlement_price() const;
  public:
  void clear_settlement_price();
  int64_t settlement_price() const;
  void set_settlement_price(int64_t value);
  private:
  int64_t _internal_settlement_price() const;
  void _internal_set_settlement_price(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.CreateMarket)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_name_;
    ::ProtoCommon::Instrument* instrument_;
    int64_t settlement_price_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CreateMarketReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.CreateMarketReply) */ {
 public:
  inline CreateMarketReply() : CreateMarketReply(nullptr) {}
  ~CreateMarketReply() override;
  explicit PROTOBUF_CONSTEXPR CreateMarketReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateMarketReply(const CreateMarketReply& from);
  CreateMarketReply(CreateMarketReply&& from) noexcept
    : CreateMarketReply() {
    *this = ::std::move(from);
  }

  inline CreateMarketReply& operator=(const CreateMarketReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateMarketReply& operator=(CreateMarketReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateMarketReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateMarketReply* internal_default_instance() {
    return reinterpret_cast<const CreateMarketReply*>(
               &_CreateMarketReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateMarketReply& a, CreateMarketReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateMarketReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateMarketReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateMarketReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateMarketReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateMarketReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateMarketReply& from) {
    CreateMarketReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateMarketReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.CreateMarketReply";
  }
  protected:
  explicit CreateMarketReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kInstrumentFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // optional string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // required .ProtoCommon.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required uint32 error_code = 2;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.CreateMarketReply)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::ProtoCommon::Instrument* instrument_;
    uint32_t error_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PositionUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.PositionUpdate) */ {
 public:
  inline PositionUpdate() : PositionUpdate(nullptr) {}
  ~PositionUpdate() override;
  explicit PROTOBUF_CONSTEXPR PositionUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionUpdate(const PositionUpdate& from);
  PositionUpdate(PositionUpdate&& from) noexcept
    : PositionUpdate() {
    *this = ::std::move(from);
  }

  inline PositionUpdate& operator=(const PositionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionUpdate& operator=(PositionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionUpdate* internal_default_instance() {
    return reinterpret_cast<const PositionUpdate*>(
               &_PositionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PositionUpdate& a, PositionUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionUpdate& from) {
    PositionUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.PositionUpdate";
  }
  protected:
  explicit PositionUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 2,
    kInstrumentFieldNumber = 1,
    kPositionFieldNumber = 3,
  };
  // required string account_name = 2;
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // required .ProtoCommon.Instrument instrument = 1;
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::ProtoCommon::Instrument& instrument() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Instrument* release_instrument();
  ::ProtoCommon::Instrument* mutable_instrument();
  void set_allocated_instrument(::ProtoCommon::Instrument* instrument);
  private:
  const ::ProtoCommon::Instrument& _internal_instrument() const;
  ::ProtoCommon::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::ProtoCommon::Instrument* instrument);
  ::ProtoCommon::Instrument* unsafe_arena_release_instrument();

  // required int64 position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  int64_t position() const;
  void set_position(int64_t value);
  private:
  int64_t _internal_position() const;
  void _internal_set_position(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoCommon.PositionUpdate)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::ProtoCommon::Instrument* instrument_;
    int64_t position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoCommon.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoCommon.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kInsertLimitOrderFieldNumber = 2,
    kInsertMarketOrderFieldNumber = 3,
    kCancelOrderFieldNumber = 4,
    kLevelUpdateFieldNumber = 5,
    kTradeFieldNumber = 6,
    kCreateMarketFieldNumber = 7,
    kCreateMarketReplyFieldNumber = 8,
    kPositionUpdateFieldNumber = 9,
  };
  // repeated .ProtoCommon.MessageType type = 1;
  int type_size() const;
  private:
  int _internal_type_size() const;
  public:
  void clear_type();
  private:
  ::ProtoCommon::MessageType _internal_type(int index) const;
  void _internal_add_type(::ProtoCommon::MessageType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_type();
  public:
  ::ProtoCommon::MessageType type(int index) const;
  void set_type(int index, ::ProtoCommon::MessageType value);
  void add_type(::ProtoCommon::MessageType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_type();

  // optional .ProtoCommon.InsertLimitOrder insert_limit_order = 2;
  bool has_insert_limit_order() const;
  private:
  bool _internal_has_insert_limit_order() const;
  public:
  void clear_insert_limit_order();
  const ::ProtoCommon::InsertLimitOrder& insert_limit_order() const;
  PROTOBUF_NODISCARD ::ProtoCommon::InsertLimitOrder* release_insert_limit_order();
  ::ProtoCommon::InsertLimitOrder* mutable_insert_limit_order();
  void set_allocated_insert_limit_order(::ProtoCommon::InsertLimitOrder* insert_limit_order);
  private:
  const ::ProtoCommon::InsertLimitOrder& _internal_insert_limit_order() const;
  ::ProtoCommon::InsertLimitOrder* _internal_mutable_insert_limit_order();
  public:
  void unsafe_arena_set_allocated_insert_limit_order(
      ::ProtoCommon::InsertLimitOrder* insert_limit_order);
  ::ProtoCommon::InsertLimitOrder* unsafe_arena_release_insert_limit_order();

  // optional .ProtoCommon.InsertMarketOrder insert_market_order = 3;
  bool has_insert_market_order() const;
  private:
  bool _internal_has_insert_market_order() const;
  public:
  void clear_insert_market_order();
  const ::ProtoCommon::InsertMarketOrder& insert_market_order() const;
  PROTOBUF_NODISCARD ::ProtoCommon::InsertMarketOrder* release_insert_market_order();
  ::ProtoCommon::InsertMarketOrder* mutable_insert_market_order();
  void set_allocated_insert_market_order(::ProtoCommon::InsertMarketOrder* insert_market_order);
  private:
  const ::ProtoCommon::InsertMarketOrder& _internal_insert_market_order() const;
  ::ProtoCommon::InsertMarketOrder* _internal_mutable_insert_market_order();
  public:
  void unsafe_arena_set_allocated_insert_market_order(
      ::ProtoCommon::InsertMarketOrder* insert_market_order);
  ::ProtoCommon::InsertMarketOrder* unsafe_arena_release_insert_market_order();

  // optional .ProtoCommon.CancelOrder cancel_order = 4;
  bool has_cancel_order() const;
  private:
  bool _internal_has_cancel_order() const;
  public:
  void clear_cancel_order();
  const ::ProtoCommon::CancelOrder& cancel_order() const;
  PROTOBUF_NODISCARD ::ProtoCommon::CancelOrder* release_cancel_order();
  ::ProtoCommon::CancelOrder* mutable_cancel_order();
  void set_allocated_cancel_order(::ProtoCommon::CancelOrder* cancel_order);
  private:
  const ::ProtoCommon::CancelOrder& _internal_cancel_order() const;
  ::ProtoCommon::CancelOrder* _internal_mutable_cancel_order();
  public:
  void unsafe_arena_set_allocated_cancel_order(
      ::ProtoCommon::CancelOrder* cancel_order);
  ::ProtoCommon::CancelOrder* unsafe_arena_release_cancel_order();

  // optional .ProtoCommon.LevelUpdate level_update = 5;
  bool has_level_update() const;
  private:
  bool _internal_has_level_update() const;
  public:
  void clear_level_update();
  const ::ProtoCommon::LevelUpdate& level_update() const;
  PROTOBUF_NODISCARD ::ProtoCommon::LevelUpdate* release_level_update();
  ::ProtoCommon::LevelUpdate* mutable_level_update();
  void set_allocated_level_update(::ProtoCommon::LevelUpdate* level_update);
  private:
  const ::ProtoCommon::LevelUpdate& _internal_level_update() const;
  ::ProtoCommon::LevelUpdate* _internal_mutable_level_update();
  public:
  void unsafe_arena_set_allocated_level_update(
      ::ProtoCommon::LevelUpdate* level_update);
  ::ProtoCommon::LevelUpdate* unsafe_arena_release_level_update();

  // optional .ProtoCommon.Trade trade = 6;
  bool has_trade() const;
  private:
  bool _internal_has_trade() const;
  public:
  void clear_trade();
  const ::ProtoCommon::Trade& trade() const;
  PROTOBUF_NODISCARD ::ProtoCommon::Trade* release_trade();
  ::ProtoCommon::Trade* mutable_trade();
  void set_allocated_trade(::ProtoCommon::Trade* trade);
  private:
  const ::ProtoCommon::Trade& _internal_trade() const;
  ::ProtoCommon::Trade* _internal_mutable_trade();
  public:
  void unsafe_arena_set_allocated_trade(
      ::ProtoCommon::Trade* trade);
  ::ProtoCommon::Trade* unsafe_arena_release_trade();

  // optional .ProtoCommon.CreateMarket create_market = 7;
  bool has_create_market() const;
  private:
  bool _internal_has_create_market() const;
  public:
  void clear_create_market();
  const ::ProtoCommon::CreateMarket& create_market() const;
  PROTOBUF_NODISCARD ::ProtoCommon::CreateMarket* release_create_market();
  ::ProtoCommon::CreateMarket* mutable_create_market();
  void set_allocated_create_market(::ProtoCommon::CreateMarket* create_market);
  private:
  const ::ProtoCommon::CreateMarket& _internal_create_market() const;
  ::ProtoCommon::CreateMarket* _internal_mutable_create_market();
  public:
  void unsafe_arena_set_allocated_create_market(
      ::ProtoCommon::CreateMarket* create_market);
  ::ProtoCommon::CreateMarket* unsafe_arena_release_create_market();

  // optional .ProtoCommon.CreateMarketReply create_market_reply = 8;
  bool has_create_market_reply() const;
  private:
  bool _internal_has_create_market_reply() const;
  public:
  void clear_create_market_reply();
  const ::ProtoCommon::CreateMarketReply& create_market_reply() const;
  PROTOBUF_NODISCARD ::ProtoCommon::CreateMarketReply* release_create_market_reply();
  ::ProtoCommon::CreateMarketReply* mutable_create_market_reply();
  void set_allocated_create_market_reply(::ProtoCommon::CreateMarketReply* create_market_reply);
  private:
  const ::ProtoCommon::CreateMarketReply& _internal_create_market_reply() const;
  ::ProtoCommon::CreateMarketReply* _internal_mutable_create_market_reply();
  public:
  void unsafe_arena_set_allocated_create_market_reply(
      ::ProtoCommon::CreateMarketReply* create_market_reply);
  ::ProtoCommon::CreateMarketReply* unsafe_arena_release_create_market_reply();

  // optional .ProtoCommon.PositionUpdate position_update = 9;
  bool has_position_update() const;
  private:
  bool _internal_has_position_update() const;
  public:
  void clear_position_update();
  const ::ProtoCommon::PositionUpdate& position_update() const;
  PROTOBUF_NODISCARD ::ProtoCommon::PositionUpdate* release_position_update();
  ::ProtoCommon::PositionUpdate* mutable_position_update();
  void set_allocated_position_update(::ProtoCommon::PositionUpdate* position_update);
  private:
  const ::ProtoCommon::PositionUpdate& _internal_position_update() const;
  ::ProtoCommon::PositionUpdate* _internal_mutable_position_update();
  public:
  void unsafe_arena_set_allocated_position_update(
      ::ProtoCommon::PositionUpdate* position_update);
  ::ProtoCommon::PositionUpdate* unsafe_arena_release_position_update();

  // @@protoc_insertion_point(class_scope:ProtoCommon.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> type_;
    ::ProtoCommon::InsertLimitOrder* insert_limit_order_;
    ::ProtoCommon::InsertMarketOrder* insert_market_order_;
    ::ProtoCommon::CancelOrder* cancel_order_;
    ::ProtoCommon::LevelUpdate* level_update_;
    ::ProtoCommon::Trade* trade_;
    ::ProtoCommon::CreateMarket* create_market_;
    ::ProtoCommon::CreateMarketReply* create_market_reply_;
    ::ProtoCommon::PositionUpdate* position_update_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Instrument

// required uint64 id = 1;
inline bool Instrument::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Instrument::has_id() const {
  return _internal_has_id();
}
inline void Instrument::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Instrument::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Instrument::id() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Instrument.id)
  return _internal_id();
}
inline void Instrument::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void Instrument::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.Instrument.id)
}

// required uint64 precision = 2;
inline bool Instrument::_internal_has_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Instrument::has_precision() const {
  return _internal_has_precision();
}
inline void Instrument::clear_precision() {
  _impl_.precision_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Instrument::_internal_precision() const {
  return _impl_.precision_;
}
inline uint64_t Instrument::precision() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Instrument.precision)
  return _internal_precision();
}
inline void Instrument::_internal_set_precision(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.precision_ = value;
}
inline void Instrument::set_precision(uint64_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.Instrument.precision)
}

// -------------------------------------------------------------------

// GenericReply

// required uint32 request_id = 1;
inline bool GenericReply::_internal_has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GenericReply::has_request_id() const {
  return _internal_has_request_id();
}
inline void GenericReply::clear_request_id() {
  _impl_.request_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GenericReply::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t GenericReply::request_id() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.GenericReply.request_id)
  return _internal_request_id();
}
inline void GenericReply::_internal_set_request_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}
inline void GenericReply::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.GenericReply.request_id)
}

// required uint32 error_code = 2;
inline bool GenericReply::_internal_has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GenericReply::has_error_code() const {
  return _internal_has_error_code();
}
inline void GenericReply::clear_error_code() {
  _impl_.error_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GenericReply::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t GenericReply::error_code() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.GenericReply.error_code)
  return _internal_error_code();
}
inline void GenericReply::_internal_set_error_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_code_ = value;
}
inline void GenericReply::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.GenericReply.error_code)
}

// optional string text = 3;
inline bool GenericReply::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GenericReply::has_text() const {
  return _internal_has_text();
}
inline void GenericReply::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericReply::text() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.GenericReply.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericReply::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.GenericReply.text)
}
inline std::string* GenericReply::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.GenericReply.text)
  return _s;
}
inline const std::string& GenericReply::_internal_text() const {
  return _impl_.text_.Get();
}
inline void GenericReply::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericReply::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericReply::release_text() {
  // @@protoc_insertion_point(field_release:ProtoCommon.GenericReply.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GenericReply::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.GenericReply.text)
}

// -------------------------------------------------------------------

// InsertLimitOrder

// required uint32 request_id = 1;
inline bool InsertLimitOrder::_internal_has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InsertLimitOrder::has_request_id() const {
  return _internal_has_request_id();
}
inline void InsertLimitOrder::clear_request_id() {
  _impl_.request_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t InsertLimitOrder::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t InsertLimitOrder::request_id() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertLimitOrder.request_id)
  return _internal_request_id();
}
inline void InsertLimitOrder::_internal_set_request_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}
inline void InsertLimitOrder::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertLimitOrder.request_id)
}

// required .ProtoCommon.Instrument instrument = 2;
inline bool InsertLimitOrder::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool InsertLimitOrder::has_instrument() const {
  return _internal_has_instrument();
}
inline void InsertLimitOrder::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::Instrument& InsertLimitOrder::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& InsertLimitOrder::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertLimitOrder.instrument)
  return _internal_instrument();
}
inline void InsertLimitOrder::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.InsertLimitOrder.instrument)
}
inline ::ProtoCommon::Instrument* InsertLimitOrder::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* InsertLimitOrder::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.InsertLimitOrder.instrument)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* InsertLimitOrder::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* InsertLimitOrder::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.InsertLimitOrder.instrument)
  return _msg;
}
inline void InsertLimitOrder::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.InsertLimitOrder.instrument)
}

// required string account_name = 3;
inline bool InsertLimitOrder::_internal_has_account_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InsertLimitOrder::has_account_name() const {
  return _internal_has_account_name();
}
inline void InsertLimitOrder::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InsertLimitOrder::account_name() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertLimitOrder.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertLimitOrder::set_account_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertLimitOrder.account_name)
}
inline std::string* InsertLimitOrder::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.InsertLimitOrder.account_name)
  return _s;
}
inline const std::string& InsertLimitOrder::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void InsertLimitOrder::_internal_set_account_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertLimitOrder::_internal_mutable_account_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertLimitOrder::release_account_name() {
  // @@protoc_insertion_point(field_release:ProtoCommon.InsertLimitOrder.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.account_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InsertLimitOrder::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.InsertLimitOrder.account_name)
}

// required uint64 volume = 4;
inline bool InsertLimitOrder::_internal_has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InsertLimitOrder::has_volume() const {
  return _internal_has_volume();
}
inline void InsertLimitOrder::clear_volume() {
  _impl_.volume_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t InsertLimitOrder::_internal_volume() const {
  return _impl_.volume_;
}
inline uint64_t InsertLimitOrder::volume() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertLimitOrder.volume)
  return _internal_volume();
}
inline void InsertLimitOrder::_internal_set_volume(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.volume_ = value;
}
inline void InsertLimitOrder::set_volume(uint64_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertLimitOrder.volume)
}

// required int64 price = 5;
inline bool InsertLimitOrder::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InsertLimitOrder::has_price() const {
  return _internal_has_price();
}
inline void InsertLimitOrder::clear_price() {
  _impl_.price_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t InsertLimitOrder::_internal_price() const {
  return _impl_.price_;
}
inline int64_t InsertLimitOrder::price() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertLimitOrder.price)
  return _internal_price();
}
inline void InsertLimitOrder::_internal_set_price(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.price_ = value;
}
inline void InsertLimitOrder::set_price(int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertLimitOrder.price)
}

// required .ProtoCommon.Side side = 6;
inline bool InsertLimitOrder::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InsertLimitOrder::has_side() const {
  return _internal_has_side();
}
inline void InsertLimitOrder::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::ProtoCommon::Side InsertLimitOrder::_internal_side() const {
  return static_cast< ::ProtoCommon::Side >(_impl_.side_);
}
inline ::ProtoCommon::Side InsertLimitOrder::side() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertLimitOrder.side)
  return _internal_side();
}
inline void InsertLimitOrder::_internal_set_side(::ProtoCommon::Side value) {
  assert(::ProtoCommon::Side_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.side_ = value;
}
inline void InsertLimitOrder::set_side(::ProtoCommon::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertLimitOrder.side)
}

// -------------------------------------------------------------------

// InsertMarketOrder

// required uint32 request_id = 1;
inline bool InsertMarketOrder::_internal_has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InsertMarketOrder::has_request_id() const {
  return _internal_has_request_id();
}
inline void InsertMarketOrder::clear_request_id() {
  _impl_.request_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t InsertMarketOrder::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t InsertMarketOrder::request_id() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertMarketOrder.request_id)
  return _internal_request_id();
}
inline void InsertMarketOrder::_internal_set_request_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}
inline void InsertMarketOrder::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertMarketOrder.request_id)
}

// required .ProtoCommon.Instrument instrument = 2;
inline bool InsertMarketOrder::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool InsertMarketOrder::has_instrument() const {
  return _internal_has_instrument();
}
inline void InsertMarketOrder::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::Instrument& InsertMarketOrder::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& InsertMarketOrder::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertMarketOrder.instrument)
  return _internal_instrument();
}
inline void InsertMarketOrder::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.InsertMarketOrder.instrument)
}
inline ::ProtoCommon::Instrument* InsertMarketOrder::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* InsertMarketOrder::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.InsertMarketOrder.instrument)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* InsertMarketOrder::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* InsertMarketOrder::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.InsertMarketOrder.instrument)
  return _msg;
}
inline void InsertMarketOrder::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.InsertMarketOrder.instrument)
}

// required string account_name = 3;
inline bool InsertMarketOrder::_internal_has_account_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InsertMarketOrder::has_account_name() const {
  return _internal_has_account_name();
}
inline void InsertMarketOrder::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InsertMarketOrder::account_name() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertMarketOrder.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertMarketOrder::set_account_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertMarketOrder.account_name)
}
inline std::string* InsertMarketOrder::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.InsertMarketOrder.account_name)
  return _s;
}
inline const std::string& InsertMarketOrder::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void InsertMarketOrder::_internal_set_account_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertMarketOrder::_internal_mutable_account_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertMarketOrder::release_account_name() {
  // @@protoc_insertion_point(field_release:ProtoCommon.InsertMarketOrder.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.account_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InsertMarketOrder::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.InsertMarketOrder.account_name)
}

// required uint64 volume = 4;
inline bool InsertMarketOrder::_internal_has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InsertMarketOrder::has_volume() const {
  return _internal_has_volume();
}
inline void InsertMarketOrder::clear_volume() {
  _impl_.volume_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t InsertMarketOrder::_internal_volume() const {
  return _impl_.volume_;
}
inline uint64_t InsertMarketOrder::volume() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertMarketOrder.volume)
  return _internal_volume();
}
inline void InsertMarketOrder::_internal_set_volume(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.volume_ = value;
}
inline void InsertMarketOrder::set_volume(uint64_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertMarketOrder.volume)
}

// required .ProtoCommon.Side side = 5;
inline bool InsertMarketOrder::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InsertMarketOrder::has_side() const {
  return _internal_has_side();
}
inline void InsertMarketOrder::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::ProtoCommon::Side InsertMarketOrder::_internal_side() const {
  return static_cast< ::ProtoCommon::Side >(_impl_.side_);
}
inline ::ProtoCommon::Side InsertMarketOrder::side() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.InsertMarketOrder.side)
  return _internal_side();
}
inline void InsertMarketOrder::_internal_set_side(::ProtoCommon::Side value) {
  assert(::ProtoCommon::Side_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.side_ = value;
}
inline void InsertMarketOrder::set_side(::ProtoCommon::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.InsertMarketOrder.side)
}

// -------------------------------------------------------------------

// CancelOrder

// required uint32 request_id = 1;
inline bool CancelOrder::_internal_has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CancelOrder::has_request_id() const {
  return _internal_has_request_id();
}
inline void CancelOrder::clear_request_id() {
  _impl_.request_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CancelOrder::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t CancelOrder::request_id() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CancelOrder.request_id)
  return _internal_request_id();
}
inline void CancelOrder::_internal_set_request_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}
inline void CancelOrder::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.CancelOrder.request_id)
}

// required .ProtoCommon.Instrument instrument = 2;
inline bool CancelOrder::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool CancelOrder::has_instrument() const {
  return _internal_has_instrument();
}
inline void CancelOrder::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::Instrument& CancelOrder::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& CancelOrder::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CancelOrder.instrument)
  return _internal_instrument();
}
inline void CancelOrder::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.CancelOrder.instrument)
}
inline ::ProtoCommon::Instrument* CancelOrder::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* CancelOrder::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.CancelOrder.instrument)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* CancelOrder::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* CancelOrder::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.CancelOrder.instrument)
  return _msg;
}
inline void CancelOrder::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.CancelOrder.instrument)
}

// required string account_name = 3;
inline bool CancelOrder::_internal_has_account_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CancelOrder::has_account_name() const {
  return _internal_has_account_name();
}
inline void CancelOrder::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CancelOrder::account_name() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CancelOrder.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrder::set_account_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.CancelOrder.account_name)
}
inline std::string* CancelOrder::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.CancelOrder.account_name)
  return _s;
}
inline const std::string& CancelOrder::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void CancelOrder::_internal_set_account_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelOrder::_internal_mutable_account_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelOrder::release_account_name() {
  // @@protoc_insertion_point(field_release:ProtoCommon.CancelOrder.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.account_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CancelOrder::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.CancelOrder.account_name)
}

// required int64 price = 4;
inline bool CancelOrder::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CancelOrder::has_price() const {
  return _internal_has_price();
}
inline void CancelOrder::clear_price() {
  _impl_.price_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t CancelOrder::_internal_price() const {
  return _impl_.price_;
}
inline int64_t CancelOrder::price() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CancelOrder.price)
  return _internal_price();
}
inline void CancelOrder::_internal_set_price(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.price_ = value;
}
inline void CancelOrder::set_price(int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.CancelOrder.price)
}

// required .ProtoCommon.Side side = 5;
inline bool CancelOrder::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CancelOrder::has_side() const {
  return _internal_has_side();
}
inline void CancelOrder::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::ProtoCommon::Side CancelOrder::_internal_side() const {
  return static_cast< ::ProtoCommon::Side >(_impl_.side_);
}
inline ::ProtoCommon::Side CancelOrder::side() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CancelOrder.side)
  return _internal_side();
}
inline void CancelOrder::_internal_set_side(::ProtoCommon::Side value) {
  assert(::ProtoCommon::Side_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.side_ = value;
}
inline void CancelOrder::set_side(::ProtoCommon::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.CancelOrder.side)
}

// -------------------------------------------------------------------

// LevelUpdate

// required .ProtoCommon.Instrument instrument = 1;
inline bool LevelUpdate::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool LevelUpdate::has_instrument() const {
  return _internal_has_instrument();
}
inline void LevelUpdate::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::Instrument& LevelUpdate::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& LevelUpdate::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.LevelUpdate.instrument)
  return _internal_instrument();
}
inline void LevelUpdate::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.LevelUpdate.instrument)
}
inline ::ProtoCommon::Instrument* LevelUpdate::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* LevelUpdate::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.LevelUpdate.instrument)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* LevelUpdate::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* LevelUpdate::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.LevelUpdate.instrument)
  return _msg;
}
inline void LevelUpdate::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.LevelUpdate.instrument)
}

// required string account_name = 2;
inline bool LevelUpdate::_internal_has_account_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LevelUpdate::has_account_name() const {
  return _internal_has_account_name();
}
inline void LevelUpdate::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LevelUpdate::account_name() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.LevelUpdate.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LevelUpdate::set_account_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.LevelUpdate.account_name)
}
inline std::string* LevelUpdate::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.LevelUpdate.account_name)
  return _s;
}
inline const std::string& LevelUpdate::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void LevelUpdate::_internal_set_account_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LevelUpdate::_internal_mutable_account_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LevelUpdate::release_account_name() {
  // @@protoc_insertion_point(field_release:ProtoCommon.LevelUpdate.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.account_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LevelUpdate::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.LevelUpdate.account_name)
}

// required uint64 volume = 3;
inline bool LevelUpdate::_internal_has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LevelUpdate::has_volume() const {
  return _internal_has_volume();
}
inline void LevelUpdate::clear_volume() {
  _impl_.volume_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t LevelUpdate::_internal_volume() const {
  return _impl_.volume_;
}
inline uint64_t LevelUpdate::volume() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.LevelUpdate.volume)
  return _internal_volume();
}
inline void LevelUpdate::_internal_set_volume(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.volume_ = value;
}
inline void LevelUpdate::set_volume(uint64_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.LevelUpdate.volume)
}

// required int64 price = 4;
inline bool LevelUpdate::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LevelUpdate::has_price() const {
  return _internal_has_price();
}
inline void LevelUpdate::clear_price() {
  _impl_.price_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t LevelUpdate::_internal_price() const {
  return _impl_.price_;
}
inline int64_t LevelUpdate::price() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.LevelUpdate.price)
  return _internal_price();
}
inline void LevelUpdate::_internal_set_price(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.price_ = value;
}
inline void LevelUpdate::set_price(int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.LevelUpdate.price)
}

// required .ProtoCommon.Side side = 5;
inline bool LevelUpdate::_internal_has_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LevelUpdate::has_side() const {
  return _internal_has_side();
}
inline void LevelUpdate::clear_side() {
  _impl_.side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::ProtoCommon::Side LevelUpdate::_internal_side() const {
  return static_cast< ::ProtoCommon::Side >(_impl_.side_);
}
inline ::ProtoCommon::Side LevelUpdate::side() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.LevelUpdate.side)
  return _internal_side();
}
inline void LevelUpdate::_internal_set_side(::ProtoCommon::Side value) {
  assert(::ProtoCommon::Side_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.side_ = value;
}
inline void LevelUpdate::set_side(::ProtoCommon::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.LevelUpdate.side)
}

// -------------------------------------------------------------------

// Trade

// required .ProtoCommon.Instrument instrument = 1;
inline bool Trade::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool Trade::has_instrument() const {
  return _internal_has_instrument();
}
inline void Trade::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::Instrument& Trade::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& Trade::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Trade.instrument)
  return _internal_instrument();
}
inline void Trade::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Trade.instrument)
}
inline ::ProtoCommon::Instrument* Trade::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* Trade::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Trade.instrument)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* Trade::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* Trade::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Trade.instrument)
  return _msg;
}
inline void Trade::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Trade.instrument)
}

// required uint64 volume = 2;
inline bool Trade::_internal_has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Trade::has_volume() const {
  return _internal_has_volume();
}
inline void Trade::clear_volume() {
  _impl_.volume_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Trade::_internal_volume() const {
  return _impl_.volume_;
}
inline uint64_t Trade::volume() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Trade.volume)
  return _internal_volume();
}
inline void Trade::_internal_set_volume(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.volume_ = value;
}
inline void Trade::set_volume(uint64_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.Trade.volume)
}

// required int64 price = 3;
inline bool Trade::_internal_has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Trade::has_price() const {
  return _internal_has_price();
}
inline void Trade::clear_price() {
  _impl_.price_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t Trade::_internal_price() const {
  return _impl_.price_;
}
inline int64_t Trade::price() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Trade.price)
  return _internal_price();
}
inline void Trade::_internal_set_price(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.price_ = value;
}
inline void Trade::set_price(int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.Trade.price)
}

// required string passive_account = 4;
inline bool Trade::_internal_has_passive_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Trade::has_passive_account() const {
  return _internal_has_passive_account();
}
inline void Trade::clear_passive_account() {
  _impl_.passive_account_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Trade::passive_account() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Trade.passive_account)
  return _internal_passive_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trade::set_passive_account(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.passive_account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.Trade.passive_account)
}
inline std::string* Trade::mutable_passive_account() {
  std::string* _s = _internal_mutable_passive_account();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Trade.passive_account)
  return _s;
}
inline const std::string& Trade::_internal_passive_account() const {
  return _impl_.passive_account_.Get();
}
inline void Trade::_internal_set_passive_account(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.passive_account_.Set(value, GetArenaForAllocation());
}
inline std::string* Trade::_internal_mutable_passive_account() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.passive_account_.Mutable(GetArenaForAllocation());
}
inline std::string* Trade::release_passive_account() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Trade.passive_account)
  if (!_internal_has_passive_account()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.passive_account_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passive_account_.IsDefault()) {
    _impl_.passive_account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trade::set_allocated_passive_account(std::string* passive_account) {
  if (passive_account != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.passive_account_.SetAllocated(passive_account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passive_account_.IsDefault()) {
    _impl_.passive_account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Trade.passive_account)
}

// required .ProtoCommon.Side passive_side = 5;
inline bool Trade::_internal_has_passive_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Trade::has_passive_side() const {
  return _internal_has_passive_side();
}
inline void Trade::clear_passive_side() {
  _impl_.passive_side_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::ProtoCommon::Side Trade::_internal_passive_side() const {
  return static_cast< ::ProtoCommon::Side >(_impl_.passive_side_);
}
inline ::ProtoCommon::Side Trade::passive_side() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Trade.passive_side)
  return _internal_passive_side();
}
inline void Trade::_internal_set_passive_side(::ProtoCommon::Side value) {
  assert(::ProtoCommon::Side_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.passive_side_ = value;
}
inline void Trade::set_passive_side(::ProtoCommon::Side value) {
  _internal_set_passive_side(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.Trade.passive_side)
}

// -------------------------------------------------------------------

// CreateMarket

// required .ProtoCommon.Instrument instrument = 1;
inline bool CreateMarket::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool CreateMarket::has_instrument() const {
  return _internal_has_instrument();
}
inline void CreateMarket::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ProtoCommon::Instrument& CreateMarket::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& CreateMarket::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CreateMarket.instrument)
  return _internal_instrument();
}
inline void CreateMarket::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.CreateMarket.instrument)
}
inline ::ProtoCommon::Instrument* CreateMarket::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* CreateMarket::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.CreateMarket.instrument)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* CreateMarket::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* CreateMarket::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.CreateMarket.instrument)
  return _msg;
}
inline void CreateMarket::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.CreateMarket.instrument)
}

// required int64 settlement_price = 2;
inline bool CreateMarket::_internal_has_settlement_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateMarket::has_settlement_price() const {
  return _internal_has_settlement_price();
}
inline void CreateMarket::clear_settlement_price() {
  _impl_.settlement_price_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t CreateMarket::_internal_settlement_price() const {
  return _impl_.settlement_price_;
}
inline int64_t CreateMarket::settlement_price() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CreateMarket.settlement_price)
  return _internal_settlement_price();
}
inline void CreateMarket::_internal_set_settlement_price(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.settlement_price_ = value;
}
inline void CreateMarket::set_settlement_price(int64_t value) {
  _internal_set_settlement_price(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.CreateMarket.settlement_price)
}

// repeated string user_name = 3;
inline int CreateMarket::_internal_user_name_size() const {
  return _impl_.user_name_.size();
}
inline int CreateMarket::user_name_size() const {
  return _internal_user_name_size();
}
inline void CreateMarket::clear_user_name() {
  _impl_.user_name_.Clear();
}
inline std::string* CreateMarket::add_user_name() {
  std::string* _s = _internal_add_user_name();
  // @@protoc_insertion_point(field_add_mutable:ProtoCommon.CreateMarket.user_name)
  return _s;
}
inline const std::string& CreateMarket::_internal_user_name(int index) const {
  return _impl_.user_name_.Get(index);
}
inline const std::string& CreateMarket::user_name(int index) const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CreateMarket.user_name)
  return _internal_user_name(index);
}
inline std::string* CreateMarket::mutable_user_name(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoCommon.CreateMarket.user_name)
  return _impl_.user_name_.Mutable(index);
}
inline void CreateMarket::set_user_name(int index, const std::string& value) {
  _impl_.user_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.CreateMarket.user_name)
}
inline void CreateMarket::set_user_name(int index, std::string&& value) {
  _impl_.user_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProtoCommon.CreateMarket.user_name)
}
inline void CreateMarket::set_user_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoCommon.CreateMarket.user_name)
}
inline void CreateMarket::set_user_name(int index, const char* value, size_t size) {
  _impl_.user_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoCommon.CreateMarket.user_name)
}
inline std::string* CreateMarket::_internal_add_user_name() {
  return _impl_.user_name_.Add();
}
inline void CreateMarket::add_user_name(const std::string& value) {
  _impl_.user_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProtoCommon.CreateMarket.user_name)
}
inline void CreateMarket::add_user_name(std::string&& value) {
  _impl_.user_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProtoCommon.CreateMarket.user_name)
}
inline void CreateMarket::add_user_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProtoCommon.CreateMarket.user_name)
}
inline void CreateMarket::add_user_name(const char* value, size_t size) {
  _impl_.user_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProtoCommon.CreateMarket.user_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateMarket::user_name() const {
  // @@protoc_insertion_point(field_list:ProtoCommon.CreateMarket.user_name)
  return _impl_.user_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateMarket::mutable_user_name() {
  // @@protoc_insertion_point(field_mutable_list:ProtoCommon.CreateMarket.user_name)
  return &_impl_.user_name_;
}

// -------------------------------------------------------------------

// CreateMarketReply

// required .ProtoCommon.Instrument instrument = 1;
inline bool CreateMarketReply::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool CreateMarketReply::has_instrument() const {
  return _internal_has_instrument();
}
inline void CreateMarketReply::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::Instrument& CreateMarketReply::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& CreateMarketReply::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CreateMarketReply.instrument)
  return _internal_instrument();
}
inline void CreateMarketReply::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.CreateMarketReply.instrument)
}
inline ::ProtoCommon::Instrument* CreateMarketReply::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* CreateMarketReply::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.CreateMarketReply.instrument)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* CreateMarketReply::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* CreateMarketReply::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.CreateMarketReply.instrument)
  return _msg;
}
inline void CreateMarketReply::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.CreateMarketReply.instrument)
}

// required uint32 error_code = 2;
inline bool CreateMarketReply::_internal_has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CreateMarketReply::has_error_code() const {
  return _internal_has_error_code();
}
inline void CreateMarketReply::clear_error_code() {
  _impl_.error_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CreateMarketReply::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t CreateMarketReply::error_code() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CreateMarketReply.error_code)
  return _internal_error_code();
}
inline void CreateMarketReply::_internal_set_error_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_code_ = value;
}
inline void CreateMarketReply::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.CreateMarketReply.error_code)
}

// optional string text = 3;
inline bool CreateMarketReply::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateMarketReply::has_text() const {
  return _internal_has_text();
}
inline void CreateMarketReply::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateMarketReply::text() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.CreateMarketReply.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateMarketReply::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.CreateMarketReply.text)
}
inline std::string* CreateMarketReply::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.CreateMarketReply.text)
  return _s;
}
inline const std::string& CreateMarketReply::_internal_text() const {
  return _impl_.text_.Get();
}
inline void CreateMarketReply::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateMarketReply::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateMarketReply::release_text() {
  // @@protoc_insertion_point(field_release:ProtoCommon.CreateMarketReply.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateMarketReply::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.CreateMarketReply.text)
}

// -------------------------------------------------------------------

// PositionUpdate

// required .ProtoCommon.Instrument instrument = 1;
inline bool PositionUpdate::_internal_has_instrument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instrument_ != nullptr);
  return value;
}
inline bool PositionUpdate::has_instrument() const {
  return _internal_has_instrument();
}
inline void PositionUpdate::clear_instrument() {
  if (_impl_.instrument_ != nullptr) _impl_.instrument_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::Instrument& PositionUpdate::_internal_instrument() const {
  const ::ProtoCommon::Instrument* p = _impl_.instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Instrument&>(
      ::ProtoCommon::_Instrument_default_instance_);
}
inline const ::ProtoCommon::Instrument& PositionUpdate::instrument() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.PositionUpdate.instrument)
  return _internal_instrument();
}
inline void PositionUpdate::unsafe_arena_set_allocated_instrument(
    ::ProtoCommon::Instrument* instrument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_);
  }
  _impl_.instrument_ = instrument;
  if (instrument) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.PositionUpdate.instrument)
}
inline ::ProtoCommon::Instrument* PositionUpdate::release_instrument() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Instrument* PositionUpdate::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:ProtoCommon.PositionUpdate.instrument)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::Instrument* temp = _impl_.instrument_;
  _impl_.instrument_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Instrument* PositionUpdate::_internal_mutable_instrument() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Instrument>(GetArenaForAllocation());
    _impl_.instrument_ = p;
  }
  return _impl_.instrument_;
}
inline ::ProtoCommon::Instrument* PositionUpdate::mutable_instrument() {
  ::ProtoCommon::Instrument* _msg = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.PositionUpdate.instrument)
  return _msg;
}
inline void PositionUpdate::set_allocated_instrument(::ProtoCommon::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.PositionUpdate.instrument)
}

// required string account_name = 2;
inline bool PositionUpdate::_internal_has_account_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PositionUpdate::has_account_name() const {
  return _internal_has_account_name();
}
inline void PositionUpdate::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PositionUpdate::account_name() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.PositionUpdate.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PositionUpdate::set_account_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoCommon.PositionUpdate.account_name)
}
inline std::string* PositionUpdate::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.PositionUpdate.account_name)
  return _s;
}
inline const std::string& PositionUpdate::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void PositionUpdate::_internal_set_account_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionUpdate::_internal_mutable_account_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PositionUpdate::release_account_name() {
  // @@protoc_insertion_point(field_release:ProtoCommon.PositionUpdate.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.account_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PositionUpdate::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.PositionUpdate.account_name)
}

// required int64 position = 3;
inline bool PositionUpdate::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PositionUpdate::has_position() const {
  return _internal_has_position();
}
inline void PositionUpdate::clear_position() {
  _impl_.position_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t PositionUpdate::_internal_position() const {
  return _impl_.position_;
}
inline int64_t PositionUpdate::position() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.PositionUpdate.position)
  return _internal_position();
}
inline void PositionUpdate::_internal_set_position(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.position_ = value;
}
inline void PositionUpdate::set_position(int64_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:ProtoCommon.PositionUpdate.position)
}

// -------------------------------------------------------------------

// Message

// repeated .ProtoCommon.MessageType type = 1;
inline int Message::_internal_type_size() const {
  return _impl_.type_.size();
}
inline int Message::type_size() const {
  return _internal_type_size();
}
inline void Message::clear_type() {
  _impl_.type_.Clear();
}
inline ::ProtoCommon::MessageType Message::_internal_type(int index) const {
  return static_cast< ::ProtoCommon::MessageType >(_impl_.type_.Get(index));
}
inline ::ProtoCommon::MessageType Message::type(int index) const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.type)
  return _internal_type(index);
}
inline void Message::set_type(int index, ::ProtoCommon::MessageType value) {
  assert(::ProtoCommon::MessageType_IsValid(value));
  _impl_.type_.Set(index, value);
  // @@protoc_insertion_point(field_set:ProtoCommon.Message.type)
}
inline void Message::_internal_add_type(::ProtoCommon::MessageType value) {
  assert(::ProtoCommon::MessageType_IsValid(value));
  _impl_.type_.Add(value);
}
inline void Message::add_type(::ProtoCommon::MessageType value) {
  _internal_add_type(value);
  // @@protoc_insertion_point(field_add:ProtoCommon.Message.type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Message::type() const {
  // @@protoc_insertion_point(field_list:ProtoCommon.Message.type)
  return _impl_.type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Message::_internal_mutable_type() {
  return &_impl_.type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Message::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:ProtoCommon.Message.type)
  return _internal_mutable_type();
}

// optional .ProtoCommon.InsertLimitOrder insert_limit_order = 2;
inline bool Message::_internal_has_insert_limit_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.insert_limit_order_ != nullptr);
  return value;
}
inline bool Message::has_insert_limit_order() const {
  return _internal_has_insert_limit_order();
}
inline void Message::clear_insert_limit_order() {
  if (_impl_.insert_limit_order_ != nullptr) _impl_.insert_limit_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ProtoCommon::InsertLimitOrder& Message::_internal_insert_limit_order() const {
  const ::ProtoCommon::InsertLimitOrder* p = _impl_.insert_limit_order_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::InsertLimitOrder&>(
      ::ProtoCommon::_InsertLimitOrder_default_instance_);
}
inline const ::ProtoCommon::InsertLimitOrder& Message::insert_limit_order() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.insert_limit_order)
  return _internal_insert_limit_order();
}
inline void Message::unsafe_arena_set_allocated_insert_limit_order(
    ::ProtoCommon::InsertLimitOrder* insert_limit_order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.insert_limit_order_);
  }
  _impl_.insert_limit_order_ = insert_limit_order;
  if (insert_limit_order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.insert_limit_order)
}
inline ::ProtoCommon::InsertLimitOrder* Message::release_insert_limit_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoCommon::InsertLimitOrder* temp = _impl_.insert_limit_order_;
  _impl_.insert_limit_order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::InsertLimitOrder* Message::unsafe_arena_release_insert_limit_order() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.insert_limit_order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoCommon::InsertLimitOrder* temp = _impl_.insert_limit_order_;
  _impl_.insert_limit_order_ = nullptr;
  return temp;
}
inline ::ProtoCommon::InsertLimitOrder* Message::_internal_mutable_insert_limit_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.insert_limit_order_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::InsertLimitOrder>(GetArenaForAllocation());
    _impl_.insert_limit_order_ = p;
  }
  return _impl_.insert_limit_order_;
}
inline ::ProtoCommon::InsertLimitOrder* Message::mutable_insert_limit_order() {
  ::ProtoCommon::InsertLimitOrder* _msg = _internal_mutable_insert_limit_order();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.insert_limit_order)
  return _msg;
}
inline void Message::set_allocated_insert_limit_order(::ProtoCommon::InsertLimitOrder* insert_limit_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.insert_limit_order_;
  }
  if (insert_limit_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(insert_limit_order);
    if (message_arena != submessage_arena) {
      insert_limit_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insert_limit_order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.insert_limit_order_ = insert_limit_order;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.insert_limit_order)
}

// optional .ProtoCommon.InsertMarketOrder insert_market_order = 3;
inline bool Message::_internal_has_insert_market_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.insert_market_order_ != nullptr);
  return value;
}
inline bool Message::has_insert_market_order() const {
  return _internal_has_insert_market_order();
}
inline void Message::clear_insert_market_order() {
  if (_impl_.insert_market_order_ != nullptr) _impl_.insert_market_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoCommon::InsertMarketOrder& Message::_internal_insert_market_order() const {
  const ::ProtoCommon::InsertMarketOrder* p = _impl_.insert_market_order_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::InsertMarketOrder&>(
      ::ProtoCommon::_InsertMarketOrder_default_instance_);
}
inline const ::ProtoCommon::InsertMarketOrder& Message::insert_market_order() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.insert_market_order)
  return _internal_insert_market_order();
}
inline void Message::unsafe_arena_set_allocated_insert_market_order(
    ::ProtoCommon::InsertMarketOrder* insert_market_order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.insert_market_order_);
  }
  _impl_.insert_market_order_ = insert_market_order;
  if (insert_market_order) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.insert_market_order)
}
inline ::ProtoCommon::InsertMarketOrder* Message::release_insert_market_order() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::InsertMarketOrder* temp = _impl_.insert_market_order_;
  _impl_.insert_market_order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::InsertMarketOrder* Message::unsafe_arena_release_insert_market_order() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.insert_market_order)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoCommon::InsertMarketOrder* temp = _impl_.insert_market_order_;
  _impl_.insert_market_order_ = nullptr;
  return temp;
}
inline ::ProtoCommon::InsertMarketOrder* Message::_internal_mutable_insert_market_order() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.insert_market_order_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::InsertMarketOrder>(GetArenaForAllocation());
    _impl_.insert_market_order_ = p;
  }
  return _impl_.insert_market_order_;
}
inline ::ProtoCommon::InsertMarketOrder* Message::mutable_insert_market_order() {
  ::ProtoCommon::InsertMarketOrder* _msg = _internal_mutable_insert_market_order();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.insert_market_order)
  return _msg;
}
inline void Message::set_allocated_insert_market_order(::ProtoCommon::InsertMarketOrder* insert_market_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.insert_market_order_;
  }
  if (insert_market_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(insert_market_order);
    if (message_arena != submessage_arena) {
      insert_market_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insert_market_order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.insert_market_order_ = insert_market_order;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.insert_market_order)
}

// optional .ProtoCommon.CancelOrder cancel_order = 4;
inline bool Message::_internal_has_cancel_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cancel_order_ != nullptr);
  return value;
}
inline bool Message::has_cancel_order() const {
  return _internal_has_cancel_order();
}
inline void Message::clear_cancel_order() {
  if (_impl_.cancel_order_ != nullptr) _impl_.cancel_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ProtoCommon::CancelOrder& Message::_internal_cancel_order() const {
  const ::ProtoCommon::CancelOrder* p = _impl_.cancel_order_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::CancelOrder&>(
      ::ProtoCommon::_CancelOrder_default_instance_);
}
inline const ::ProtoCommon::CancelOrder& Message::cancel_order() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.cancel_order)
  return _internal_cancel_order();
}
inline void Message::unsafe_arena_set_allocated_cancel_order(
    ::ProtoCommon::CancelOrder* cancel_order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_order_);
  }
  _impl_.cancel_order_ = cancel_order;
  if (cancel_order) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.cancel_order)
}
inline ::ProtoCommon::CancelOrder* Message::release_cancel_order() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ProtoCommon::CancelOrder* temp = _impl_.cancel_order_;
  _impl_.cancel_order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::CancelOrder* Message::unsafe_arena_release_cancel_order() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.cancel_order)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ProtoCommon::CancelOrder* temp = _impl_.cancel_order_;
  _impl_.cancel_order_ = nullptr;
  return temp;
}
inline ::ProtoCommon::CancelOrder* Message::_internal_mutable_cancel_order() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cancel_order_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::CancelOrder>(GetArenaForAllocation());
    _impl_.cancel_order_ = p;
  }
  return _impl_.cancel_order_;
}
inline ::ProtoCommon::CancelOrder* Message::mutable_cancel_order() {
  ::ProtoCommon::CancelOrder* _msg = _internal_mutable_cancel_order();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.cancel_order)
  return _msg;
}
inline void Message::set_allocated_cancel_order(::ProtoCommon::CancelOrder* cancel_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cancel_order_;
  }
  if (cancel_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cancel_order);
    if (message_arena != submessage_arena) {
      cancel_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cancel_order_ = cancel_order;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.cancel_order)
}

// optional .ProtoCommon.LevelUpdate level_update = 5;
inline bool Message::_internal_has_level_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.level_update_ != nullptr);
  return value;
}
inline bool Message::has_level_update() const {
  return _internal_has_level_update();
}
inline void Message::clear_level_update() {
  if (_impl_.level_update_ != nullptr) _impl_.level_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ProtoCommon::LevelUpdate& Message::_internal_level_update() const {
  const ::ProtoCommon::LevelUpdate* p = _impl_.level_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::LevelUpdate&>(
      ::ProtoCommon::_LevelUpdate_default_instance_);
}
inline const ::ProtoCommon::LevelUpdate& Message::level_update() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.level_update)
  return _internal_level_update();
}
inline void Message::unsafe_arena_set_allocated_level_update(
    ::ProtoCommon::LevelUpdate* level_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.level_update_);
  }
  _impl_.level_update_ = level_update;
  if (level_update) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.level_update)
}
inline ::ProtoCommon::LevelUpdate* Message::release_level_update() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ProtoCommon::LevelUpdate* temp = _impl_.level_update_;
  _impl_.level_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::LevelUpdate* Message::unsafe_arena_release_level_update() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.level_update)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ProtoCommon::LevelUpdate* temp = _impl_.level_update_;
  _impl_.level_update_ = nullptr;
  return temp;
}
inline ::ProtoCommon::LevelUpdate* Message::_internal_mutable_level_update() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.level_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::LevelUpdate>(GetArenaForAllocation());
    _impl_.level_update_ = p;
  }
  return _impl_.level_update_;
}
inline ::ProtoCommon::LevelUpdate* Message::mutable_level_update() {
  ::ProtoCommon::LevelUpdate* _msg = _internal_mutable_level_update();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.level_update)
  return _msg;
}
inline void Message::set_allocated_level_update(::ProtoCommon::LevelUpdate* level_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.level_update_;
  }
  if (level_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(level_update);
    if (message_arena != submessage_arena) {
      level_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, level_update, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.level_update_ = level_update;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.level_update)
}

// optional .ProtoCommon.Trade trade = 6;
inline bool Message::_internal_has_trade() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trade_ != nullptr);
  return value;
}
inline bool Message::has_trade() const {
  return _internal_has_trade();
}
inline void Message::clear_trade() {
  if (_impl_.trade_ != nullptr) _impl_.trade_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::ProtoCommon::Trade& Message::_internal_trade() const {
  const ::ProtoCommon::Trade* p = _impl_.trade_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::Trade&>(
      ::ProtoCommon::_Trade_default_instance_);
}
inline const ::ProtoCommon::Trade& Message::trade() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.trade)
  return _internal_trade();
}
inline void Message::unsafe_arena_set_allocated_trade(
    ::ProtoCommon::Trade* trade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trade_);
  }
  _impl_.trade_ = trade;
  if (trade) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.trade)
}
inline ::ProtoCommon::Trade* Message::release_trade() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ProtoCommon::Trade* temp = _impl_.trade_;
  _impl_.trade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::Trade* Message::unsafe_arena_release_trade() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.trade)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ProtoCommon::Trade* temp = _impl_.trade_;
  _impl_.trade_ = nullptr;
  return temp;
}
inline ::ProtoCommon::Trade* Message::_internal_mutable_trade() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::Trade>(GetArenaForAllocation());
    _impl_.trade_ = p;
  }
  return _impl_.trade_;
}
inline ::ProtoCommon::Trade* Message::mutable_trade() {
  ::ProtoCommon::Trade* _msg = _internal_mutable_trade();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.trade)
  return _msg;
}
inline void Message::set_allocated_trade(::ProtoCommon::Trade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trade_;
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trade);
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.trade)
}

// optional .ProtoCommon.CreateMarket create_market = 7;
inline bool Message::_internal_has_create_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.create_market_ != nullptr);
  return value;
}
inline bool Message::has_create_market() const {
  return _internal_has_create_market();
}
inline void Message::clear_create_market() {
  if (_impl_.create_market_ != nullptr) _impl_.create_market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::ProtoCommon::CreateMarket& Message::_internal_create_market() const {
  const ::ProtoCommon::CreateMarket* p = _impl_.create_market_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::CreateMarket&>(
      ::ProtoCommon::_CreateMarket_default_instance_);
}
inline const ::ProtoCommon::CreateMarket& Message::create_market() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.create_market)
  return _internal_create_market();
}
inline void Message::unsafe_arena_set_allocated_create_market(
    ::ProtoCommon::CreateMarket* create_market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_market_);
  }
  _impl_.create_market_ = create_market;
  if (create_market) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.create_market)
}
inline ::ProtoCommon::CreateMarket* Message::release_create_market() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ProtoCommon::CreateMarket* temp = _impl_.create_market_;
  _impl_.create_market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::CreateMarket* Message::unsafe_arena_release_create_market() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.create_market)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ProtoCommon::CreateMarket* temp = _impl_.create_market_;
  _impl_.create_market_ = nullptr;
  return temp;
}
inline ::ProtoCommon::CreateMarket* Message::_internal_mutable_create_market() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.create_market_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::CreateMarket>(GetArenaForAllocation());
    _impl_.create_market_ = p;
  }
  return _impl_.create_market_;
}
inline ::ProtoCommon::CreateMarket* Message::mutable_create_market() {
  ::ProtoCommon::CreateMarket* _msg = _internal_mutable_create_market();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.create_market)
  return _msg;
}
inline void Message::set_allocated_create_market(::ProtoCommon::CreateMarket* create_market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.create_market_;
  }
  if (create_market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_market);
    if (message_arena != submessage_arena) {
      create_market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.create_market_ = create_market;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.create_market)
}

// optional .ProtoCommon.CreateMarketReply create_market_reply = 8;
inline bool Message::_internal_has_create_market_reply() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.create_market_reply_ != nullptr);
  return value;
}
inline bool Message::has_create_market_reply() const {
  return _internal_has_create_market_reply();
}
inline void Message::clear_create_market_reply() {
  if (_impl_.create_market_reply_ != nullptr) _impl_.create_market_reply_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::ProtoCommon::CreateMarketReply& Message::_internal_create_market_reply() const {
  const ::ProtoCommon::CreateMarketReply* p = _impl_.create_market_reply_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::CreateMarketReply&>(
      ::ProtoCommon::_CreateMarketReply_default_instance_);
}
inline const ::ProtoCommon::CreateMarketReply& Message::create_market_reply() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.create_market_reply)
  return _internal_create_market_reply();
}
inline void Message::unsafe_arena_set_allocated_create_market_reply(
    ::ProtoCommon::CreateMarketReply* create_market_reply) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_market_reply_);
  }
  _impl_.create_market_reply_ = create_market_reply;
  if (create_market_reply) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.create_market_reply)
}
inline ::ProtoCommon::CreateMarketReply* Message::release_create_market_reply() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::ProtoCommon::CreateMarketReply* temp = _impl_.create_market_reply_;
  _impl_.create_market_reply_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::CreateMarketReply* Message::unsafe_arena_release_create_market_reply() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.create_market_reply)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::ProtoCommon::CreateMarketReply* temp = _impl_.create_market_reply_;
  _impl_.create_market_reply_ = nullptr;
  return temp;
}
inline ::ProtoCommon::CreateMarketReply* Message::_internal_mutable_create_market_reply() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.create_market_reply_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::CreateMarketReply>(GetArenaForAllocation());
    _impl_.create_market_reply_ = p;
  }
  return _impl_.create_market_reply_;
}
inline ::ProtoCommon::CreateMarketReply* Message::mutable_create_market_reply() {
  ::ProtoCommon::CreateMarketReply* _msg = _internal_mutable_create_market_reply();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.create_market_reply)
  return _msg;
}
inline void Message::set_allocated_create_market_reply(::ProtoCommon::CreateMarketReply* create_market_reply) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.create_market_reply_;
  }
  if (create_market_reply) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_market_reply);
    if (message_arena != submessage_arena) {
      create_market_reply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_market_reply, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.create_market_reply_ = create_market_reply;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.create_market_reply)
}

// optional .ProtoCommon.PositionUpdate position_update = 9;
inline bool Message::_internal_has_position_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_update_ != nullptr);
  return value;
}
inline bool Message::has_position_update() const {
  return _internal_has_position_update();
}
inline void Message::clear_position_update() {
  if (_impl_.position_update_ != nullptr) _impl_.position_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::ProtoCommon::PositionUpdate& Message::_internal_position_update() const {
  const ::ProtoCommon::PositionUpdate* p = _impl_.position_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoCommon::PositionUpdate&>(
      ::ProtoCommon::_PositionUpdate_default_instance_);
}
inline const ::ProtoCommon::PositionUpdate& Message::position_update() const {
  // @@protoc_insertion_point(field_get:ProtoCommon.Message.position_update)
  return _internal_position_update();
}
inline void Message::unsafe_arena_set_allocated_position_update(
    ::ProtoCommon::PositionUpdate* position_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_update_);
  }
  _impl_.position_update_ = position_update;
  if (position_update) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoCommon.Message.position_update)
}
inline ::ProtoCommon::PositionUpdate* Message::release_position_update() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ProtoCommon::PositionUpdate* temp = _impl_.position_update_;
  _impl_.position_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoCommon::PositionUpdate* Message::unsafe_arena_release_position_update() {
  // @@protoc_insertion_point(field_release:ProtoCommon.Message.position_update)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ProtoCommon::PositionUpdate* temp = _impl_.position_update_;
  _impl_.position_update_ = nullptr;
  return temp;
}
inline ::ProtoCommon::PositionUpdate* Message::_internal_mutable_position_update() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.position_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoCommon::PositionUpdate>(GetArenaForAllocation());
    _impl_.position_update_ = p;
  }
  return _impl_.position_update_;
}
inline ::ProtoCommon::PositionUpdate* Message::mutable_position_update() {
  ::ProtoCommon::PositionUpdate* _msg = _internal_mutable_position_update();
  // @@protoc_insertion_point(field_mutable:ProtoCommon.Message.position_update)
  return _msg;
}
inline void Message::set_allocated_position_update(::ProtoCommon::PositionUpdate* position_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_update_;
  }
  if (position_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position_update);
    if (message_arena != submessage_arena) {
      position_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_update, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.position_update_ = position_update;
  // @@protoc_insertion_point(field_set_allocated:ProtoCommon.Message.position_update)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoCommon

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ProtoCommon::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoCommon::MessageType>() {
  return ::ProtoCommon::MessageType_descriptor();
}
template <> struct is_proto_enum< ::ProtoCommon::Side> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoCommon::Side>() {
  return ::ProtoCommon::Side_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto
